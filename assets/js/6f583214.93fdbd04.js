"use strict";(self.webpackChunkbridging_tutorial_website=self.webpackChunkbridging_tutorial_website||[]).push([[1396],{5162:(e,n,t)=>{t.d(n,{Z:()=>r});var i=t(7294),o=t(6010);const a={tabItem:"tabItem_Ymn6"};function r(e){let{children:n,hidden:t,className:r}=e;return i.createElement("div",{role:"tabpanel",className:(0,o.Z)(a.tabItem,r),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>k});var i=t(7462),o=t(7294),a=t(6010),r=t(2466),l=t(6550),s=t(1980),d=t(7392),c=t(12);function p(e){return function(e){return o.Children.map(e,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:i,default:o}}=e;return{value:n,label:t,attributes:i,default:o}}))}function u(e){const{values:n,children:t}=e;return(0,o.useMemo)((()=>{const e=n??p(t);return function(e){const n=(0,d.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const i=(0,l.k6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,s._X)(a),(0,o.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(i.location.search);n.set(a,e),i.replace({...i.location,search:n.toString()})}),[a,i])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,a=u(e),[r,l]=(0,o.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const i=t.find((e=>e.default))??t[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:a}))),[s,d]=h({queryString:t,groupId:i}),[p,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,a]=(0,c.Nk)(t);return[i,(0,o.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:i}),g=(()=>{const e=s??p;return m({value:e,tabValues:a})?e:null})();(0,o.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:r,selectValue:(0,o.useCallback)((e=>{if(!m({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),f(e)}),[d,f,a]),tabValues:a}}var g=t(2389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function N(e){let{className:n,block:t,selectedValue:l,selectValue:s,tabValues:d}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,r.o5)(),u=e=>{const n=e.currentTarget,t=c.indexOf(n),i=d[t].value;i!==l&&(p(n),s(i))},m=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":t},n)},d.map((e=>{let{value:n,label:t,attributes:r}=e;return o.createElement("li",(0,i.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>c.push(e),onKeyDown:m,onClick:u},r,{className:(0,a.Z)("tabs__item",v.tabItem,r?.className,{"tabs__item--active":l===n})}),t??n)})))}function S(e){let{lazy:n,children:t,selectedValue:i}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===i));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==i}))))}function O(e){const n=f(e);return o.createElement("div",{className:(0,a.Z)("tabs-container",v.tabList)},o.createElement(N,(0,i.Z)({},e,n)),o.createElement(S,(0,i.Z)({},e,n)))}function k(e){const n=(0,g.Z)();return o.createElement(O,(0,i.Z)({key:String(n)},e))}},6162:(e,n,t)=>{t.d(n,{ZP:()=>s});var i=t(7462),o=(t(7294),t(3905)),a=t(814);const r={toc:[]},l="wrapper";function s(e){let{components:n,...t}=e;return(0,o.kt)(l,(0,i.Z)({},r,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Complete ",(0,o.kt)("code",null,t.filename)," file"),(0,o.kt)("div",null,(0,o.kt)(a.Z,{language:t.language,mdxType:"CodeBlock"},t.children))))}s.isMDXComponent=!0},5403:(e,n,t)=>{t.d(n,{ZP:()=>l});var i=t(7462),o=(t(7294),t(3905));const a={toc:[]},r="wrapper";function l(e){let{components:n,...t}=e;return(0,o.kt)(r,(0,i.Z)({},a,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"To make Swift elements accessible to Objective-C world, we have to do 4 things:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"make class extending ",(0,o.kt)("inlineCode",{parentName:"li"},"NSObject")),(0,o.kt)("li",{parentName:"ul"},"mark class and its methods (at least those methods that are meant to be exposed) as public"),(0,o.kt)("li",{parentName:"ul"},"mark class with ",(0,o.kt)("inlineCode",{parentName:"li"},"@objc(exported-objc-name)")," decorator"),(0,o.kt)("li",{parentName:"ul"},"mark exposed methods with ",(0,o.kt)("inlineCode",{parentName:"li"},"@objc")," decorator"))))}l.isMDXComponent=!0},321:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>T,contentTitle:()=>E,default:()=>L,frontMatter:()=>I,metadata:()=>D,toc:()=>_});var i=t(7462),o=(t(7294),t(3905)),a=t(4866),r=t(5162),l=t(6162);const s={toc:[{value:"<code>ScreenOrientationModule.h</code>",id:"screenorientationmoduleh",level:4},{value:"<code>ScreenOrientationModule.mm</code>",id:"screenorientationmodulemm",level:4}]},d="wrapper";function c(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,i.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h4",{id:"screenorientationmoduleh"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModule.h")),(0,o.kt)("p",null,"Now, let's go to the module to glue the native events and constants to the JS code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.h"',title:'"ios/ScreenOrientationModule.h"'},"#import <React/RCTEventEmitter.h>\n\n/**\n * Declare the ObjC interface for that native module class.\n * \n * It must extend NSObject (like every class in ObjC) and\n * implement RCTBridgeModule (like each RN native module).\n * \n * If the module emits events, it must extend RCTEventEmitter class.\n */\n@interface ScreenOrientationModule : RCTEventEmitter\n\n@end\n")),(0,o.kt)("p",null,"In the header file for ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," class we declare our class extending ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTEventEmitter")," (as each RN iOS module with events emitting capability)."),(0,o.kt)("h4",{id:"screenorientationmodulemm"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModule.mm")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},'#import "ScreenOrientationModule.h"\n\n#import "ScreenOrientationModuleImpl.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "ScreenOrientationPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface ScreenOrientationModule () <NativeScreenOrientationModuleSpec>\n@end\n#endif\n\n// Declare the ObjC implementation for that native module class\n@implementation ScreenOrientationModule\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(ScreenOrientationModule)\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeScreenOrientationModuleSpecJSI>(params);\n}\n#endif\n\n@end\n')),(0,o.kt)("p",null,"This is the implementation file for ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," class."),(0,o.kt)("p",null,"Before declaring the implementation block, we have to import ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," header,\nand we have to implement code-generated spec protocol for new architecture (code between ",(0,o.kt)("inlineCode",{parentName:"p"},"#if RCT_NEW_ARCH_ENABLED")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"#endif")," directives)."),(0,o.kt)("p",null,"After that, inside implementation block we have ",(0,o.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro invoked with ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," argument. This basically registers the module with provided name on iOS side, so that it's accessible in the JS world."),(0,o.kt)("p",null,"Also, for new architecture, it implements ",(0,o.kt)("inlineCode",{parentName:"p"},"- getTurboModule:")," method (from ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTTurboModule")," protocol).\nIf you won't implement that method, XCode will complain that the code-generated spec protocol methods are not implemented."),(0,o.kt)("p",null,"Let's use ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},"// ...\n\n// highlight-start\n@interface ScreenOrientationModule () <ScreenOrientationModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n// highlight-end\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(ScreenOrientationModule)\n\n// highlight-start\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [ScreenOrientationModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n// highlight-end\n\n// ...\n\n@end\n")),(0,o.kt)("p",null,"First, we declare ",(0,o.kt)("inlineCode",{parentName:"p"},"moduleImpl")," private variable on ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," that will be initialized in the ",(0,o.kt)("inlineCode",{parentName:"p"},"- init")," method.\nWe can use ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," Swift class, because it's imported from ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationPackage-Swift.h"),"."),(0,o.kt)("p",null,"We also declare ",(0,o.kt)("inlineCode",{parentName:"p"},"hasListeners")," variable, we will use it to check if there're any JS listeners registered to the module."),(0,o.kt)("p",null,"Next, we override static method ",(0,o.kt)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup"),", which must be done whenever ",(0,o.kt)("inlineCode",{parentName:"p"},"- init")," method on the RN's wrapper class is overriden."),(0,o.kt)("p",null,"To handle events-specific methods from parent ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTEventEmitter")," class, we need to override 3 methods:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},"// ...\n\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// ...\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n\n// highlight-start\n// Declare which events will be emitted by the module\n- (NSArray<NSString *> *)supportedEvents\n{\n    return [ScreenOrientationModuleImpl supportedEvents];\n}\n\n- (void)startObserving\n{\n    hasListeners = YES;\n}\n\n- (void)stopObserving\n{\n    hasListeners = NO;\n}\n// highlight-end\n\n// ...\n\n@end\n")),(0,o.kt)("p",null,"To mark which events will be emitted by the module, we need to override ",(0,o.kt)("inlineCode",{parentName:"p"},"- supportedEvents")," getter - we use the value from ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class as a source of truth.\nTwo other methods, are called when the first/last JS observer is registered/unregistered."),(0,o.kt)("p",null,"We still have to emit the events received from ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," - as you may noticed, XCode displayed a warning about ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleDelegate"),".\nThe module class is marked to be implementing the delegate protocol,\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," delegate property is set to this module instance,\nbut we still need to implement delegate's methods."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},"// ...\n\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// ...\n\n- (void)stopObserving\n{\n    hasListeners = NO;\n}\n\n// highlight-start\n- (void)sendEventWithName:(NSString * _Nonnull)eventName\n                  payload:(NSDictionary<NSString *,id> * _Nonnull)payload\n{\n    if (hasListeners) {\n        [self sendEventWithName:eventName body:payload];\n    }\n}\n// highlight-end\n\n// ...\n\n@end\n")),(0,o.kt)("p",null,"In the delegate's method, the module checks if there's any receiver that listens to events and if yes, invokes ",(0,o.kt)("inlineCode",{parentName:"p"},"- sendEventWithName:body:")," method from ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTEventEmitter")," base class."),(0,o.kt)("p",null,"The last thing to do is to export constants to the JS world."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},'// ...\n\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// ...\n\n- (void)sendEventWithName:(NSString * _Nonnull)eventName\n                  payload:(NSDictionary<NSString *,id> * _Nonnull)payload\n{\n    if (hasListeners) {\n        [self sendEventWithName:eventName body:payload];\n    }\n}\n\n// highlight-start\n/**\n * Declare constants exported by the module\n */\n#if RCT_NEW_ARCH_ENABLED\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)constantsToExport\n{\n    return [self getConstants];\n}\n\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)getConstants {\n    return facebook::react::typedConstants<JS::NativeScreenOrientationModule::Constants::Builder>({\n        .PORTRAIT = @"portrait",\n        .LANDSCAPE = @"landscape"\n    });\n}\n#else\n- (NSDictionary *)constantsToExport\n{\n    return @{ @"PORTRAIT": @"portrait", @"LANDSCAPE": @"landscape" };\n}\n#endif\n// highlight-end\n\n// ...\n\n@end\n')),(0,o.kt)("p",null,"In old architecture mode, it's super simple, we have to return an object (",(0,o.kt)("inlineCode",{parentName:"p"},"NSDictionary *"),") from ",(0,o.kt)("inlineCode",{parentName:"p"},"- constantsToExport")," method."),(0,o.kt)("p",null,"In new architecture mode, it looks a bit more complex:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"we use code-generated type-safe C++ structs instead of ",(0,o.kt)("inlineCode",{parentName:"li"},"NSDictionary *")," type"),(0,o.kt)("li",{parentName:"ul"},"together with ",(0,o.kt)("inlineCode",{parentName:"li"},"- constantsToExport")," we have to override ",(0,o.kt)("inlineCode",{parentName:"li"},"- getConstants")," method (both return type-safe C++ structs)"),(0,o.kt)("li",{parentName:"ul"},"to produce type-safe struct, we use ",(0,o.kt)("inlineCode",{parentName:"li"},"facebook::react::typedConstants")," function")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"If you're wondering where all those C++ structs are defined, you can find ",(0,o.kt)("inlineCode",{parentName:"p"},'#import "ScreenOrientationPackage.h"'),' in XCode, Cmd+Click on it and select "Jump to Definition" action.')),(0,o.kt)(l.ZP,{filename:"ScreenOrientationModule.mm",language:"objc",mdxType:"CompleteFile"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'#import "ScreenOrientationModule.h"\n\n#import "ScreenOrientationModuleImpl.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n* Import header file with codegenerated protocols based on the JS specification\n*\n* The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n*/\n#import "ScreenOrientationPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface ScreenOrientationModule () <NativeScreenOrientationModuleSpec>\n@end\n#endif\n\n@interface ScreenOrientationModule () <ScreenOrientationModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(ScreenOrientationModule)\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [ScreenOrientationModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n\n// Declare which events will be emitted by the module\n- (NSArray<NSString *> *)supportedEvents\n{\n    return [ScreenOrientationModuleImpl supportedEvents];\n}\n\n- (void)startObserving\n{\n    hasListeners = YES;\n}\n\n- (void)stopObserving\n{\n    hasListeners = NO;\n}\n\n- (void)sendEventWithName:(NSString * _Nonnull)eventName\n                  payload:(NSDictionary<NSString *,id> * _Nonnull)payload\n{\n    if (hasListeners) {\n        [self sendEventWithName:eventName body:payload];\n    }\n}\n\n/**\n* Declare constants exported by the module\n*/\n#if RCT_NEW_ARCH_ENABLED\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)constantsToExport\n{\n    return [self getConstants];\n}\n\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)getConstants {\n    return facebook::react::typedConstants<JS::NativeScreenOrientationModule::Constants::Builder>({\n        .PORTRAIT = @"portrait",\n        .LANDSCAPE = @"landscape"\n    });\n}\n#else\n- (NSDictionary *)constantsToExport\n{\n    return @{ @"PORTRAIT": @"portrait", @"LANDSCAPE": @"landscape" };\n}\n#endif\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeScreenOrientationModuleSpecJSI>(params);\n}\n#endif\n\n@end\n'))))}c.isMDXComponent=!0;const p={toc:[{value:"<code>ScreenOrientationModuleImpl.h</code>",id:"screenorientationmoduleimplh",level:4},{value:"<code>ScreenOrientationModuleImpl.mm</code>",id:"screenorientationmoduleimplmm",level:4}]},u="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The complete flow when the orientation changes will look like that:"),(0,o.kt)("p",null,"Orientation notification is emitted -> Notification handler is receiving the notification -> Notification handler is determining if the event should be emitted -> Notification handler emits event to the Delegate class "),(0,o.kt)("h4",{id:"screenorientationmoduleimplh"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModuleImpl.h")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModuleImpl.h"',title:'"ios/ScreenOrientationModuleImpl.h"'},"#import <Foundation/Foundation.h>\n\ntypedef NS_ENUM(NSUInteger, ScreenOrientationModuleEvent) {\n  OnScreenOrientationModuleChange,\n};\n\nextern NSString * _Nonnull ScreenOrientationModuleEventName(ScreenOrientationModuleEvent event);\n\n@protocol ScreenOrientationModuleDelegate\n\n- (void)sendEventWithName:(NSString * _Nonnull)eventName\n                  payload:(NSDictionary<NSString *, id> * _Nonnull)payload;\n\n@end\n\n@interface ScreenOrientationModuleImpl : NSObject\n\n@property (nonatomic, weak) id <ScreenOrientationModuleDelegate> _Nullable delegate;\n\n@end\n\n@interface ScreenOrientationModuleImpl ()\n\n+ (NSArray<NSString *> * _Nonnull)supportedEvents;\n\n@end\n")),(0,o.kt)("p",null,"Here, we declare ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class together with ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleDelegate")," protocol."),(0,o.kt)("p",null,"The class will have weak delegate property and a static getter.\nAlso at the top, we declare an enum for possible events (in this case there will only be one)."),(0,o.kt)("p",null,"Now let's implement the class in the implementation file"),(0,o.kt)("h4",{id:"screenorientationmoduleimplmm"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModuleImpl.mm")),(0,o.kt)("p",null,"Let's start by connecting to the orientation notifications."),(0,o.kt)("p",null,"To listen to orientation events, we will register this class as an observer on the default instance of ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/nsnotificationcenter?language=objc"},(0,o.kt)("inlineCode",{parentName:"a"},"NSNotificationCenter")),"."),(0,o.kt)("p",null,"Additionally, to trigger device orientation notifications, we need to explicitly start/stop them\nwith ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidevice/1620041-begingeneratingdeviceorientation?language=objc"},(0,o.kt)("inlineCode",{parentName:"a"},"beginGeneratingDeviceOrientationNotifications")),"\nand ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidevice/1620033-endgeneratingdeviceorientationno?language=objc"},(0,o.kt)("inlineCode",{parentName:"a"},"endGeneratingDeviceOrientationNotifications"))," methods."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModuleImpl.mm"',title:'"ios/ScreenOrientationModuleImpl.mm"'},'#import "ScreenOrientationModuleImpl.h"\n\n/**\n * Native module\'s shared implementation\n */\n@implementation ScreenOrientationModuleImpl {\n    NSString *lastOrientation;\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        lastOrientation = @"unknown";\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleOrientationChange:) name:UIDeviceOrientationDidChangeNotification object:[UIDevice currentDevice]];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];\n        });\n    }\n    return self;\n}\n\n- (void)dealloc\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications];\n    });\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n\n- (void)handleOrientationChange:(NSNotification *)notification\n{\n    //\n}\n\n@end\n')),(0,o.kt)("p",null,"You can notice, that ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class overrides initializer and deinitializer.\nInside initializer, we register the module as an observer of the notification (via ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/nsnotificationcenter/1415360-addobserver?language=objc"},(0,o.kt)("inlineCode",{parentName:"a"},"addObserver(_:selector:name:object:)")),") and we start generating orientation notifications.\nWhen the class ends its life, those operations should be reverted. And that's done in the ",(0,o.kt)("inlineCode",{parentName:"p"},"dealloc")," function - orientation notifications are stopped, and the listener is unregistered (via ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/nsnotificationcenter/1413994-removeobserver?language=objc"},(0,o.kt)("inlineCode",{parentName:"a"},"removeObserver(_:)")),").\nReceived notification will be handled inside ",(0,o.kt)("inlineCode",{parentName:"p"},"- handleOrientationChange"),", which will be implemented in the next step."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModuleImpl.mm"',title:'"ios/ScreenOrientationModuleImpl.mm"'},'#import "ScreenOrientationModuleImpl.h"\n\n// highlight-start\nNSString *ScreenOrientationModuleEventName(ScreenOrientationModuleEvent event)\n{\n  switch (event) {\n    case OnScreenOrientationModuleChange:\n      return @"onScreenOrientationModuleChange";\n  }\n}\n// highlight-end\n\n/**\n * Native module\'s shared implementation\n */\n@implementation ScreenOrientationModuleImpl {\n    NSString *lastOrientation;\n}\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        lastOrientation = @"unknown";\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleOrientationChange:) name:UIDeviceOrientationDidChangeNotification object:[UIDevice currentDevice]];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];\n        });\n    }\n    return self;\n}\n\n- (void)dealloc\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications];\n    });\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n\n// highlight-start\n/**\n * Example usage:\n *\n * ```objc\n * [self sendEvent:<%- moduleName %>EventName(On<%- moduleName %>Change) payload:@{ @"value" : result }];\n * ````\n */\n- (void)sendEvent:(NSString *)name payload:(NSDictionary<NSString *, id> *)payload {\n    [self.delegate sendEventWithName:name payload:payload];\n}\n\n+ (NSArray<NSString *> *)supportedEvents\n{\n    return @[ScreenOrientationModuleEventName(OnScreenOrientationModuleChange)];\n}\n// highlight-end\n\n- (void)handleOrientationChange:(NSNotification *)notification\n{\n    // highlight-start\n    UIDeviceOrientation currentOrientation = [[UIDevice currentDevice] orientation];\n    \n    NSString *orientation = @"unknown";\n    if (currentOrientation == UIDeviceOrientationPortrait || currentOrientation == UIDeviceOrientationPortraitUpsideDown) {\n        orientation = @"portrait";\n    } else if (currentOrientation == UIDeviceOrientationLandscapeLeft || currentOrientation == UIDeviceOrientationLandscapeRight) {\n        orientation = @"landscape";\n    }\n    \n    if (lastOrientation == orientation) {\n        return;\n    }\n    lastOrientation = orientation;\n    \n    [self sendEvent:ScreenOrientationModuleEventName(OnScreenOrientationModuleChange)\n            payload:@{@"orientation": orientation}];\n    // highlight-end\n}\n\n@end\n')),(0,o.kt)("p",null,"We added 3 snippets of code, the 1st one implements helper function that translates Objective-C enum to the string.\nThe 2nd snippet adds a convienient helper for emitting events to the delegate and implements ",(0,o.kt)("inlineCode",{parentName:"p"},"supportedEvents")," static getter.\nThe last snippet is adding the logic that compares current orientation value with the previous one and sends an event when there's new value to be emitted."))}m.isMDXComponent=!0;const h={toc:[]},f="wrapper";function g(e){let{components:n,...t}=e;return(0,o.kt)(f,(0,i.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)(m,{mdxType:"IosObjCModuleImpl"}),(0,o.kt)(c,{mdxType:"IosObjCModule"}))}g.isMDXComponent=!0;const v={toc:[{value:"<code>ScreenOrientationModule.h</code>",id:"screenorientationmoduleh",level:4},{value:"<code>ScreenOrientationModule.mm</code>",id:"screenorientationmodulemm",level:4}]},N="wrapper";function S(e){let{components:n,...t}=e;return(0,o.kt)(N,(0,i.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h4",{id:"screenorientationmoduleh"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModule.h")),(0,o.kt)("p",null,"Now, let's go to the module to glue the native events and constants to the JS code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.h"',title:'"ios/ScreenOrientationModule.h"'},'#import <React/RCTEventEmitter.h>\n\n/**\n * When using Swift classes in ObjC header, the class must have its\n * "forward declaration"\n * \n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations\n */\n@class ScreenOrientationModuleImpl;\n\n/**\n * Declare the ObjC interface for that native module class.\n * \n * It must extend NSObject (like every class in ObjC) and\n * implement RCTBridgeModule (like each RN native module).\n * \n * If the module emits events, it must extend RCTEventEmitter class.\n */\n@interface ScreenOrientationModule : RCTEventEmitter\n\n@end\n')),(0,o.kt)("p",null,"In the header file for ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," class we declare our class extending ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTEventEmitter")," (as each RN iOS module with events emitting capability)."),(0,o.kt)("p",null,"Additionally, to use Swift ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl"),' class, we must do "forward-declaration" (check out Apple\'s Swift-ObjC interop ',(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations"},"dedicated docs section"),")."),(0,o.kt)("h4",{id:"screenorientationmodulemm"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModule.mm")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},'#import "ScreenOrientationModule.h"\n\n/**\n * When using Swift classes in ObjC implementation, the classes must be imported\n * from generated Objective-C Interface Header\n *\n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Import-Code-Within-an-App-Target\n */\n#import "ScreenOrientationPackage-Swift.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "ScreenOrientationPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface ScreenOrientationModule () <NativeScreenOrientationModuleSpec>\n@end\n#endif\n\n// Declare the ObjC implementation for that native module class\n@implementation ScreenOrientationModule\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(ScreenOrientationModule)\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeScreenOrientationModuleSpecJSI>(params);\n}\n#endif\n\n@end\n')),(0,o.kt)("p",null,"This is the implementation file for ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," class."),(0,o.kt)("p",null,"Before declaring the implementation block, we have to import Swift-ObjC generated interface header (check out ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations"},"dedicated docs section"),"),\nand we have to implement code-generated spec protocol for new architecture (code between ",(0,o.kt)("inlineCode",{parentName:"p"},"#if RCT_NEW_ARCH_ENABLED")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"#endif")," directives)."),(0,o.kt)("p",null,"After that, inside implementation block we have ",(0,o.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro invoked with ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," argument. This basically registers the module with provided name on iOS side, so that it's accessible in the JS world."),(0,o.kt)("p",null,"Also, for new architecture, it implements ",(0,o.kt)("inlineCode",{parentName:"p"},"- getTurboModule:")," method (from ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTTurboModule")," protocol).\nIf you won't implement that method, XCode will complain that the code-generated spec protocol methods are not implemented."),(0,o.kt)("p",null,"Let's use ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},"// ...\n\n// highlight-start\n@interface ScreenOrientationModule () <ScreenOrientationModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n// highlight-end\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(ScreenOrientationModule)\n\n// highlight-start\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [ScreenOrientationModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n// highlight-end\n\n// ...\n\n@end\n")),(0,o.kt)("p",null,"First, we declare ",(0,o.kt)("inlineCode",{parentName:"p"},"moduleImpl")," private variable on ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," that will be initialized in the ",(0,o.kt)("inlineCode",{parentName:"p"},"- init")," method.\nWe can use ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," Swift class, because it's imported from ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationPackage-Swift.h"),"."),(0,o.kt)("p",null,"We also declare ",(0,o.kt)("inlineCode",{parentName:"p"},"hasListeners")," variable, we will use it to check if there're any JS listeners registered to the module."),(0,o.kt)("p",null,"Next, we override static method ",(0,o.kt)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup"),", which must be done whenever ",(0,o.kt)("inlineCode",{parentName:"p"},"- init")," method on the RN's wrapper class is overriden."),(0,o.kt)("p",null,"To handle events-specific methods from parent ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTEventEmitter")," class, we need to override 3 methods:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},"// ...\n\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// ...\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n\n// highlight-start\n// Declare which events will be emitted by the module\n- (NSArray<NSString *> *)supportedEvents\n{\n    return [ScreenOrientationModuleImpl supportedEvents];\n}\n\n- (void)startObserving\n{\n    hasListeners = YES;\n}\n\n- (void)stopObserving\n{\n    hasListeners = NO;\n}\n// highlight-end\n\n// ...\n\n@end\n")),(0,o.kt)("p",null,"To mark which events will be emitted by the module, we need to override ",(0,o.kt)("inlineCode",{parentName:"p"},"- supportedEvents")," getter - we use the value from ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class as a source of truth.\nTwo other methods, are called when the first/last JS observer is registered/unregistered."),(0,o.kt)("p",null,"We still have to emit the events received from ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," - as you may noticed, XCode displayed a warning about ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleDelegate"),".\nThe module class is marked to be implementing the delegate protocol,\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," delegate property is set to this module instance,\nbut we still need to implement delegate's methods."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},"// ...\n\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// ...\n\n- (void)stopObserving\n{\n    hasListeners = NO;\n}\n\n// highlight-start\n- (void)sendEventWithName:(NSString * _Nonnull)eventName\n                  payload:(NSDictionary<NSString *,id> * _Nonnull)payload\n{\n    if (hasListeners) {\n        [self sendEventWithName:eventName body:payload];\n    }\n}\n// highlight-end\n\n// ...\n\n@end\n")),(0,o.kt)("p",null,"In the delegate's method, the module checks if there's any receiver that listens to events and if yes, invokes ",(0,o.kt)("inlineCode",{parentName:"p"},"- sendEventWithName:body:")," method from ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTEventEmitter")," base class."),(0,o.kt)("p",null,"The last thing to do is to export constants to the JS world."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ScreenOrientationModule.mm"',title:'"ios/ScreenOrientationModule.mm"'},'// ...\n\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// ...\n\n- (void)sendEventWithName:(NSString * _Nonnull)eventName\n                  payload:(NSDictionary<NSString *,id> * _Nonnull)payload\n{\n    if (hasListeners) {\n        [self sendEventWithName:eventName body:payload];\n    }\n}\n\n// highlight-start\n/**\n * Declare constants exported by the module\n */\n#if RCT_NEW_ARCH_ENABLED\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)constantsToExport\n{\n    return [self getConstants];\n}\n\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)getConstants {\n    return facebook::react::typedConstants<JS::NativeScreenOrientationModule::Constants::Builder>({\n        .PORTRAIT = @"portrait",\n        .LANDSCAPE = @"landscape"\n    });\n}\n#else\n- (NSDictionary *)constantsToExport\n{\n    return @{ @"PORTRAIT": @"portrait", @"LANDSCAPE": @"landscape" };\n}\n#endif\n// highlight-end\n\n// ...\n\n@end\n')),(0,o.kt)("p",null,"In old architecture mode, it's super simple, we have to return an object (",(0,o.kt)("inlineCode",{parentName:"p"},"NSDictionary *"),") from ",(0,o.kt)("inlineCode",{parentName:"p"},"- constantsToExport")," method."),(0,o.kt)("p",null,"In new architecture mode, it looks a bit more complex:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"we use code-generated type-safe C++ structs instead of ",(0,o.kt)("inlineCode",{parentName:"li"},"NSDictionary *")," type"),(0,o.kt)("li",{parentName:"ul"},"together with ",(0,o.kt)("inlineCode",{parentName:"li"},"- constantsToExport")," we have to override ",(0,o.kt)("inlineCode",{parentName:"li"},"- getConstants")," method (both return type-safe C++ structs)"),(0,o.kt)("li",{parentName:"ul"},"to produce type-safe struct, we use ",(0,o.kt)("inlineCode",{parentName:"li"},"facebook::react::typedConstants")," function")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"If you're wondering where all those C++ structs are defined, you can find ",(0,o.kt)("inlineCode",{parentName:"p"},'#import "ScreenOrientationPackage.h"'),' in XCode, Cmd+Click on it and select "Jump to Definition" action.')),(0,o.kt)(l.ZP,{filename:"ScreenOrientationModule.mm",language:"objc",mdxType:"CompleteFile"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'#import "ScreenOrientationModule.h"\n\n/**\n* When using Swift classes in ObjC implementation, the classes must be imported\n* from generated Objective-C Interface Header\n*\n* @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Import-Code-Within-an-App-Target\n*/\n#import "ScreenOrientationPackage-Swift.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n* Import header file with codegenerated protocols based on the JS specification\n*\n* The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n*/\n#import "ScreenOrientationPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface ScreenOrientationModule () <NativeScreenOrientationModuleSpec>\n@end\n#endif\n\n@interface ScreenOrientationModule () <ScreenOrientationModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation ScreenOrientationModule {\n    ScreenOrientationModuleImpl *moduleImpl;\n    BOOL hasListeners;\n}\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(ScreenOrientationModule)\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [ScreenOrientationModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n\n// Declare which events will be emitted by the module\n- (NSArray<NSString *> *)supportedEvents\n{\n    return [ScreenOrientationModuleImpl supportedEvents];\n}\n\n- (void)startObserving\n{\n    hasListeners = YES;\n}\n\n- (void)stopObserving\n{\n    hasListeners = NO;\n}\n\n- (void)sendEventWithName:(NSString * _Nonnull)eventName\n                  payload:(NSDictionary<NSString *,id> * _Nonnull)payload\n{\n    if (hasListeners) {\n        [self sendEventWithName:eventName body:payload];\n    }\n}\n\n/**\n* Declare constants exported by the module\n*/\n#if RCT_NEW_ARCH_ENABLED\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)constantsToExport\n{\n    return [self getConstants];\n}\n\n- (facebook::react::ModuleConstants<JS::NativeScreenOrientationModule::Constants::Builder>)getConstants {\n    return facebook::react::typedConstants<JS::NativeScreenOrientationModule::Constants::Builder>({\n        .PORTRAIT = @"portrait",\n        .LANDSCAPE = @"landscape"\n    });\n}\n#else\n- (NSDictionary *)constantsToExport\n{\n    return @{ @"PORTRAIT": @"portrait", @"LANDSCAPE": @"landscape" };\n}\n#endif\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeScreenOrientationModuleSpecJSI>(params);\n}\n#endif\n\n@end\n'))))}S.isMDXComponent=!0;var O=t(5403);const k={toc:[{value:"<code>ScreenOrientationModuleImpl.swift</code>",id:"screenorientationmoduleimplswift",level:4}]},b="wrapper";function C(e){let{components:n,...t}=e;return(0,o.kt)(b,(0,i.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The complete flow when the orientation changes will look like that:"),(0,o.kt)("p",null,"Orientation notification is emitted -> Notification handler is receiving the notification -> Notification handler is determining if the event should be emitted -> Notification handler emits event to the Delegate class "),(0,o.kt)("h4",{id:"screenorientationmoduleimplswift"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModuleImpl.swift")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/ScreenOrientationModuleImpl.swift"',title:'"ios/ScreenOrientationModuleImpl.swift"'},"import Foundation\n\n@objc(ScreenOrientationModuleDelegate)\npublic protocol ScreenOrientationModuleDelegate {\n    func sendEvent(name: String, payload: Dictionary<String, Any>)\n}\n\n/**\n * Native module's shared implementation\n */\n@objc(ScreenOrientationModuleImpl)\npublic class ScreenOrientationModuleImpl : NSObject {\n    @objc public weak var delegate: ScreenOrientationModuleDelegate? = nil\n    \n    @objc func handleOrientationChange(notification: NSNotification) {\n        //\n    }\n}\n")),(0,o.kt)("p",null,"Here, we declare ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class together with ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleDelegate")," protocol."),(0,o.kt)(O.ZP,{mdxType:"ExportingObjCInfo"}),(0,o.kt)("p",null,"The class will have weak delegate property and a method that will be called with the notification parameter every time device is changing its orientation."),(0,o.kt)("p",null,"To listen to orientation events, we will register this class as an observer on the default instance of ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/notificationcenter"},(0,o.kt)("inlineCode",{parentName:"a"},"NotificationCenter")),"."),(0,o.kt)("p",null,"Additionally, to trigger device orientation notifications, we need to explicitly start/stop them\nwith ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidevice/1620041-begingeneratingdeviceorientation"},(0,o.kt)("inlineCode",{parentName:"a"},"beginGeneratingDeviceOrientationNotifications")),"\nand ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidevice/1620033-endgeneratingdeviceorientationno"},(0,o.kt)("inlineCode",{parentName:"a"},"endGeneratingDeviceOrientationNotifications"))," methods."),(0,o.kt)("p",null,"Ok, now let's connect to the orientation notifications"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/ScreenOrientationModuleImpl.swift"',title:'"ios/ScreenOrientationModuleImpl.swift"'},"// ...\n\n/**\n * Native module's shared implementation\n */\n@objc(ScreenOrientationModuleImpl)\npublic class ScreenOrientationModuleImpl : NSObject {\n    @objc public weak var delegate: ScreenOrientationModuleDelegate? = nil\n\n// highlight-start\n    public override init() {\n        super.init()\n        NotificationCenter.default.addObserver(self, selector: #selector(self.handleOrientationChange(notification:)), name: UIDevice.orientationDidChangeNotification, object: UIDevice.current)\n        DispatchQueue.main.async {\n            UIDevice.current.beginGeneratingDeviceOrientationNotifications()\n        }\n    }\n    \n    deinit {\n        DispatchQueue.main.async {\n            UIDevice.current.endGeneratingDeviceOrientationNotifications()\n        }\n        NotificationCenter.default.removeObserver(self)\n    }\n// highlight-end\n    \n    @objc func handleOrientationChange(notification: NSNotification) {\n        //\n    }\n}\n")),(0,o.kt)("p",null,"You can notice, that ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class got initializer and deinitializer.\nInside initializer, we register the module as an observer of the notification (via ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/notificationcenter/1415360-addobserver"},(0,o.kt)("inlineCode",{parentName:"a"},"addObserver(_:selector:name:object:)")),") and we start generating orientation notifications.\nWhen the class ends its life, those operations should be reverted. And that's done in the ",(0,o.kt)("inlineCode",{parentName:"p"},"deinit")," block - orientation notifications are stopped, and the listener is unregistered (via ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver"},(0,o.kt)("inlineCode",{parentName:"a"},"removeObserver(_:)")),")."),(0,o.kt)("p",null,"Next step is to handle the notification and emit the event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/ScreenOrientationModuleImpl.swift"',title:'"ios/ScreenOrientationModuleImpl.swift"'},'// ...\n\n/**\n * Native module\'s shared implementation\n */\n@objc(ScreenOrientationModuleImpl)\npublic class ScreenOrientationModuleImpl : NSObject {\n    @objc public weak var delegate: ScreenOrientationModuleDelegate? = nil\n\n// highlight-start\n    /**\n     * Example usage:\n     *\n     * ```swift\n     * self.sendEvent(name: Event.onScreenOrientationModuleChange.rawValue, payload: [ "value" : result ])\n     * ````\n     */\n    private func sendEvent(name: String, payload: Dictionary<String, Any>) {\n        self.delegate?.sendEvent(name: name, payload: payload)\n    }\n\n    private var lastOrientation = "unknown"\n// highlight-end\n\n    public override init() {\n        super.init()\n        NotificationCenter.default.addObserver(self, selector: #selector(self.handleOrientationChange(notification:)), name: UIDevice.orientationDidChangeNotification, object: UIDevice.current)\n        DispatchQueue.main.async {\n            UIDevice.current.beginGeneratingDeviceOrientationNotifications()\n        }\n    }\n    \n    deinit {\n        DispatchQueue.main.async {\n            UIDevice.current.endGeneratingDeviceOrientationNotifications()\n        }\n        NotificationCenter.default.removeObserver(self)\n    }\n    \n    @objc func handleOrientationChange(notification: NSNotification) {\n// highlight-start\n        let currentOrientation = UIDevice.current.orientation\n        \n        var orientation = "unknown"\n        if currentOrientation == UIDeviceOrientation.portrait || currentOrientation == UIDeviceOrientation.portraitUpsideDown {\n            orientation = "portrait"\n        } else if currentOrientation == UIDeviceOrientation.landscapeLeft || currentOrientation == UIDeviceOrientation.landscapeRight {\n            orientation = "landscape"\n        }\n\n        if lastOrientation == orientation {\n            return\n        }\n        lastOrientation = orientation\n        \n        self.sendEvent(name: Event.onScreenOrientationModuleChange.rawValue, payload: ["orientation": orientation])\n// highlight-end\n    }\n}\n\n// highlight-start\nextension ScreenOrientationModuleImpl {\n    enum Event: String, CaseIterable {\n        case onScreenOrientationModuleChange\n    }\n\n    @objc(supportedEvents)\n    public static var supportedEvents: [String] {\n        return Event.allCases.map(\\.rawValue);\n    }\n}\n// highlight-end\n')),(0,o.kt)("p",null,"We added 3 snippets of code, the 1st one adds a convienient helper for emitting events to the delegate and a variable that keeps last emitted value.\nThe 2nd snippet is adding the logic that compares current orientation value with the previous one and sends an event when there's new value to be emitted.\nThe last snippet declares an extension on ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"Event")," enum and ",(0,o.kt)("inlineCode",{parentName:"p"},"supportedEvents")," static getter."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"For more on ",(0,o.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions"},"extensions")," or ",(0,o.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations"},"enums")," in Swift, visit Swift's docs.")))}C.isMDXComponent=!0;const M={toc:[]},w="wrapper";function y(e){let{components:n,...t}=e;return(0,o.kt)(w,(0,i.Z)({},M,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)(C,{mdxType:"IosSwiftModuleImpl"}),(0,o.kt)(S,{mdxType:"IosSwiftModule"}))}y.isMDXComponent=!0;const I={sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},E=void 0,D={unversionedId:"guides/screen-orientation-module/ios-impl",id:"guides/screen-orientation-module/ios-impl",title:"iOS implementation",description:"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:",source:"@site/docs/guides/screen-orientation-module/ios-impl.mdx",sourceDirName:"guides/screen-orientation-module",slug:"/guides/screen-orientation-module/ios-impl",permalink:"/rnbridgingtutorial/docs/guides/screen-orientation-module/ios-impl",draft:!1,editUrl:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/docs/docs/guides/screen-orientation-module/ios-impl.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},sidebar:"tutorialSidebar",previous:{title:"JS specification",permalink:"/rnbridgingtutorial/docs/guides/screen-orientation-module/js-spec"},next:{title:"Android implementation",permalink:"/rnbridgingtutorial/docs/guides/screen-orientation-module/android-impl"}},T={},_=[],j={toc:_},R="wrapper";function L(e){let{components:n,...t}=e;return(0,o.kt)(R,(0,i.Z)({},j,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"xed ios\n")),(0,o.kt)("p",null,"When workspace is opened, locate ",(0,o.kt)("inlineCode",{parentName:"p"},"Pods")," project and expand it. Search for ",(0,o.kt)("inlineCode",{parentName:"p"},"Development Pods")," and find ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationPackage")," inside. When it's expanded, it will show all files that we created under ",(0,o.kt)("inlineCode",{parentName:"p"},"screen-orientation-package/ios")," directory."),(0,o.kt)(a.Z,{groupId:"ios_lang",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"swift",label:"ObjC++ & Swift",mdxType:"TabItem"},(0,o.kt)(y,{mdxType:"IosSwiftImpl"})),(0,o.kt)(r.Z,{value:"objc",label:"ObjC++ only",mdxType:"TabItem"},(0,o.kt)(g,{mdxType:"IosObjCImpl"}))),(0,o.kt)("p",null,"You can check training repo for Objective-C & Swift implementation ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/screen-orientation-package"},"here")," and Objective-C-only implementation ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/screen-orientation-package-classic"},"here"),"."),(0,o.kt)("p",null,"That's iOS part, now let's go to ",(0,o.kt)("a",{parentName:"p",href:"./android-impl"},"Android"),"!"))}L.isMDXComponent=!0}}]);