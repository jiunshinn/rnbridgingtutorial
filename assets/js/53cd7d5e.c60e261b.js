"use strict";(self.webpackChunkbridging_tutorial_website=self.webpackChunkbridging_tutorial_website||[]).push([[554],{5162:(e,n,a)=>{a.d(n,{Z:()=>o});var t=a(7294),l=a(6010);const i={tabItem:"tabItem_Ymn6"};function o(e){let{children:n,hidden:a,className:o}=e;return t.createElement("div",{role:"tabpanel",className:(0,l.Z)(i.tabItem,o),hidden:a},n)}},4866:(e,n,a)=>{a.d(n,{Z:()=>C});var t=a(7462),l=a(7294),i=a(6010),o=a(2466),r=a(6550),c=a(1980),s=a(7392),u=a(12);function p(e){return function(e){return l.Children.map(e,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:a,attributes:t,default:l}}=e;return{value:n,label:a,attributes:t,default:l}}))}function d(e){const{values:n,children:a}=e;return(0,l.useMemo)((()=>{const e=n??p(a);return function(e){const n=(0,s.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,a])}function m(e){let{value:n,tabValues:a}=e;return a.some((e=>e.value===n))}function k(e){let{queryString:n=!1,groupId:a}=e;const t=(0,r.k6)(),i=function(e){let{queryString:n=!1,groupId:a}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:n,groupId:a});return[(0,c._X)(i),(0,l.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})}),[i,t])]}function v(e){const{defaultValue:n,queryString:a=!1,groupId:t}=e,i=d(e),[o,r]=(0,l.useState)((()=>function(e){let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=a.find((e=>e.default))??a[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:i}))),[c,s]=k({queryString:a,groupId:t}),[p,v]=function(e){let{groupId:n}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(n),[t,i]=(0,u.Nk)(a);return[t,(0,l.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:t}),h=(()=>{const e=c??p;return m({value:e,tabValues:i})?e:null})();(0,l.useLayoutEffect)((()=>{h&&r(h)}),[h]);return{selectedValue:o,selectValue:(0,l.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);r(e),s(e),v(e)}),[s,v,i]),tabValues:i}}var h=a(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:n,block:a,selectedValue:r,selectValue:c,tabValues:s}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,o.o5)(),d=e=>{const n=e.currentTarget,a=u.indexOf(n),t=s[a].value;t!==r&&(p(n),c(t))},m=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;n=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;n=u[a]??u[u.length-1];break}}n?.focus()};return l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},n)},s.map((e=>{let{value:n,label:a,attributes:o}=e;return l.createElement("li",(0,t.Z)({role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,key:n,ref:e=>u.push(e),onKeyDown:m,onClick:d},o,{className:(0,i.Z)("tabs__item",b.tabItem,o?.className,{"tabs__item--active":r===n})}),a??n)})))}function g(e){let{lazy:n,children:a,selectedValue:t}=e;if(a=Array.isArray(a)?a:[a],n){const e=a.find((e=>e.props.value===t));return e?(0,l.cloneElement)(e,{className:"margin-top--md"}):null}return l.createElement("div",{className:"margin-top--md"},a.map(((e,n)=>(0,l.cloneElement)(e,{key:n,hidden:e.props.value!==t}))))}function M(e){const n=v(e);return l.createElement("div",{className:(0,i.Z)("tabs-container",b.tabList)},l.createElement(f,(0,t.Z)({},e,n)),l.createElement(g,(0,t.Z)({},e,n)))}function C(e){const n=(0,h.Z)();return l.createElement(M,(0,t.Z)({key:String(n)},e))}},6105:(e,n,a)=>{a.d(n,{ZP:()=>c});var t=a(7462),l=(a(7294),a(3905)),i=a(814);const o={toc:[]},r="wrapper";function c(e){let{components:n,...a}=e;return(0,l.kt)(r,(0,t.Z)({},o,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",null,(0,l.kt)("code",null,a.packageClass,".","java"===a.language?"java":"kt")),(0,l.kt)("p",null,"The last thing we need to do is to export ",(0,l.kt)("code",null,a.moduleClass)," in the ",(0,l.kt)("code",null,"TurboReactPackage")," instance. Let's go to ",(0,l.kt)("code",null,a.packageClass,".","java"===a.language?"java":"kt")," and add our new module."),(0,l.kt)(i.Z,{language:a.language,title:`android/src/main/java/com/${a.namespace}/${a.packageClass}.${"java"===a.language?"java":"kt"}`,mdxType:"CodeBlock"},"java"===a.language?`package com.${a.namespace};\n\nimport androidx.annotation.Nullable;\n\nimport com.facebook.react.TurboReactPackage;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.module.annotations.ReactModule;\nimport com.facebook.react.module.model.ReactModuleInfo;\nimport com.facebook.react.module.model.ReactModuleInfoProvider;\nimport com.facebook.react.turbomodule.core.interfaces.TurboModule;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ${a.packageClass} extends TurboReactPackage {\n    /**\n     * Initialize and export modules based on the name of the required module\n     */\n    @Override\n    @Nullable\n    public NativeModule getModule(String name, ReactApplicationContext reactContext) {\n        ${a.moduleClass?`// highlight-start\n        if (name.equals(${a.moduleClass}.NAME)) {\n            return new ${a.moduleClass}(reactContext);\n        }\n        return null;\n// highlight-end`:"return null;"}\n    }\n\n    /**\n     * Declare info about exported modules\n     */\n    @Override\n    public ReactModuleInfoProvider getReactModuleInfoProvider() {\n        /**\n         * Here declare the array of exported modules\n         */\n        Class<? extends NativeModule>[] moduleList = new Class[] {${a.moduleClass?`\n// highlight-start\n            ${a.moduleClass}.class\n            // highlight-end`:""}\n        };\n        final Map<String, ReactModuleInfo> reactModuleInfoMap = new HashMap<>();\n        /**\n         * And here just iterate on that array and produce the info provider instance\n         */\n        for (Class<? extends NativeModule> moduleClass : moduleList) {\n            ReactModule reactModule = moduleClass.getAnnotation(ReactModule.class);\n\n            reactModuleInfoMap.put(\n                reactModule.name(),\n                new ReactModuleInfo(\n                    reactModule.name(),\n                    moduleClass.getName(),\n                    true,\n                    reactModule.needsEagerInit(),\n                    reactModule.hasConstants(),\n                    reactModule.isCxxModule(),\n                    TurboModule.class.isAssignableFrom(moduleClass)\n                )\n            );\n        }\n\n        return new ReactModuleInfoProvider() {\n            @Override\n            public Map<String, ReactModuleInfo> getReactModuleInfos() {\n                return reactModuleInfoMap;\n            }\n        };\n    }${a.viewManagerClass?`\n\n// highlight-start\n    @Override\n    public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {\n        /**\n        * Here declare the list of exported native components\n        */\n        return Arrays.<ViewManager>asList(new ${a.viewManagerClass}());\n    }\n    // highlight-end`:""}\n}`:`package com.${a.namespace}\n\nimport com.facebook.react.TurboReactPackage\nimport com.facebook.react.bridge.NativeModule\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.module.annotations.ReactModule\nimport com.facebook.react.module.model.ReactModuleInfo\nimport com.facebook.react.module.model.ReactModuleInfoProvider\nimport com.facebook.react.turbomodule.core.interfaces.TurboModule\n\nclass ${a.packageClass} : TurboReactPackage() {\n    /**\n     * Initialize and export modules based on the name of the required module\n     */\n    override fun getModule(name: String, reactContext: ReactApplicationContext): NativeModule? {\n        ${a.moduleClass?`// highlight-start\n        return when (name) {\n            ${a.moduleClass}.NAME -> ${a.moduleClass}(reactContext)\n            else -> null\n        }\n        // highlight-end`:"return null;"}\n    }\n\n    /**\n     * Declare info about exported modules\n     */\n    override fun getReactModuleInfoProvider(): ReactModuleInfoProvider {\n        /**\n         * Here declare the array of exported modules\n         */\n        val moduleList: Array<Class<out NativeModule?>> = arrayOf(${a.moduleClass?`\n// highlight-start\n            ${a.moduleClass}::class.java\n            // highlight-end`:""}\n        )\n        val reactModuleInfoMap: MutableMap<String, ReactModuleInfo> = HashMap()\n        /**\n         * And here just iterate on that array and produce the info provider instance\n         */\n        for (moduleClass in moduleList) {\n            val reactModule = moduleClass.getAnnotation(ReactModule::class.java) ?: continue\n            reactModuleInfoMap[reactModule.name] =\n                ReactModuleInfo(\n                    reactModule.name,\n                    moduleClass.name,\n                    true,\n                    reactModule.needsEagerInit,\n                    reactModule.hasConstants,\n                    reactModule.isCxxModule,\n                    TurboModule::class.java.isAssignableFrom(moduleClass)\n                )\n        }\n        return ReactModuleInfoProvider { reactModuleInfoMap }\n    }${a.viewManagerClass?`\n\n// highlight-start\n    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {\n        /**\n        * Here declare the list of exported native components\n        */\n        return listOf(${a.viewManagerClass}())\n    }\n    // highlight-end`:""}\n}`),(0,l.kt)("div",null,a.moduleClass?(0,l.kt)("div",null,(0,l.kt)("p",null,"To export the module, as the first step, we need to return it from ",(0,l.kt)("code",null,"getModule")," method inside ",(0,l.kt)("code",null,a.packageClass),", if it's requested (the method takes name as a parameter and makes decision which module should be served)."),(0,l.kt)("p",null,"The second step is to implement ",(0,l.kt)("code",null,"getReactModuleInfoProvider")," method, where the module is injected to the info provider instance.")):a.viewManagerClass?(0,l.kt)("p",null,"Here the most important bit is ",(0,l.kt)("code",null,"createViewManagers")," method, which returns collection of view manager classes. Because our package exports only a single view, we register one-element list, with ",(0,l.kt)("code",null,a.viewManagerClass)," class."):null))}c.isMDXComponent=!0},6162:(e,n,a)=>{a.d(n,{ZP:()=>c});var t=a(7462),l=(a(7294),a(3905)),i=a(814);const o={toc:[]},r="wrapper";function c(e){let{components:n,...a}=e;return(0,l.kt)(r,(0,t.Z)({},o,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Complete ",(0,l.kt)("code",null,a.filename)," file"),(0,l.kt)("div",null,(0,l.kt)(i.Z,{language:a.language,mdxType:"CodeBlock"},a.children))))}c.isMDXComponent=!0},5259:(e,n,a)=>{a.d(n,{ZP:()=>c});var t=a(7462),l=(a(7294),a(3905)),i=a(814);const o={toc:[]},r="wrapper";function c(e){let{components:n,...a}=e;return(0,l.kt)(r,(0,t.Z)({},o,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Old architecture module"),(0,l.kt)("div",null,"The implementation of old architecture module won't be visible in Android Studio when you have new architecture enabled. To handle that, you can open ",(0,l.kt)("code",null,a.filename)," at other text editor and paste following content:",(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)(i.Z,{language:a.language,mdxType:"CodeBlock"},a.children))))}c.isMDXComponent=!0},4545:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>T,contentTitle:()=>E,default:()=>U,frontMatter:()=>R,metadata:()=>B,toc:()=>j});var t=a(7462),l=(a(7294),a(3905)),i=a(4866),o=a(5162),r=a(6105),c=a(6162),s=a(5259);const u={toc:[{value:"<code>SaveFilePickerModule.java</code>",id:"savefilepickermodulejava",level:4}]},p="wrapper";function d(e){let{components:n,...a}=e;return(0,l.kt)(p,(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"savefilepickermodulejava"},(0,l.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModule.java")),(0,l.kt)("p",null,"Now, let's move to the module that will manage function calls from the JS world:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"'},"package com.savefilepickerpackage\n\nimport android.net.Uri;\n\nimport androidx.annotation.Nullable;\n\nimport com.facebook.react.bridge.Arguments;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.Callback;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.module.annotations.ReactModule;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * Declare Java class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\npublic class SaveFilePickerModule extends NativeSaveFilePickerModuleSpec {\n    public static final String NAME = SaveFilePickerModuleImpl.NAME;\n\n    // Use shared module implementation and forward react application context\n    private final SaveFilePickerModuleImpl moduleImpl;\n\n    public SaveFilePickerModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n        this.moduleImpl = new SaveFilePickerModuleImpl(reactContext);\n    }\n\n    // Return the name of the module - it should match the name provided in JS specification\n    @Override\n    public String getName() {\n        return SaveFilePickerModuleImpl.NAME;\n    }\n\n    // Exported methods must be annotated with @ReactMethod decorator\n    @ReactMethod\n    public void saveFileWithCallback(String filename, Callback callback) {\n        //\n    }\n\n    @ReactMethod\n    public void saveFileWithPromise(String filename, Promise promise) {\n        //\n    }\n}\n")),(0,l.kt)("p",null,"Here we declare the ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," class.\nIt extends codegenerated spec class and takes ",(0,l.kt)("inlineCode",{parentName:"p"},"ReactApplicationContext")," instance as constructor parameter.\nAdditionally, ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," is annotated with ",(0,l.kt)("inlineCode",{parentName:"p"},"ReactModule")," decorator.\nStatic constant ",(0,l.kt)("inlineCode",{parentName:"p"},"NAME")," matches the value declared in JS specification."),(0,l.kt)("p",null,"For now, we start by adding empty implementations for methods declared in codegenerated spec class."),(0,l.kt)("p",null,"Now, let's add private variables for callback/promise blocks - we'll need to save them, once the exported methods are invoked and use, once there's result from the file activity picker."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"'},'// ...\n\n/**\n * Declare Java class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\npublic class SaveFilePickerModule extends NativeSaveFilePickerModuleSpec {\n    // ...\n    \n    // Use shared module implementation and forward react application context\n    private final SaveFilePickerModuleImpl moduleImpl;\n\n// highlight-start\n    private @Nullable Callback callbackBlock = null;\n    private @Nullable Promise promiseBlock = null;\n    private String sourceFilename = "";\n// highlight-end\n\n// ...\n}\n')),(0,l.kt)("p",null,"Next step is to implement listener object that will use callback/promise blocks to communicate the result to the JS code.\nWe will do it inside constructor:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"'},'// ...\n\n/**\n * Declare Java class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\npublic class SaveFilePickerModule extends NativeSaveFilePickerModuleSpec {\n    // ...\n\n    private @Nullable Callback callbackBlock = null;\n    private @Nullable Promise promiseBlock = null;\n    private String sourceFilename = "";\n\n// highlight-start\n    public SaveFilePickerModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n        this.moduleImpl = new SaveFilePickerModuleImpl(reactContext);\n        SaveFilePickerModuleImpl.listener = new SaveFilePickerModuleImpl.SaveFilePickerListener() {\n            @Override\n            public void onSuccess(@Nullable Uri uri) {\n                try {\n                    InputStream sourceInputStream = reactContext\n                        .getApplicationContext()\n                        .getAssets()\n                        .open(sourceFilename);\n                    if (uri != null) {\n                        OutputStream outputStream = reactContext\n                            .getContentResolver()\n                            .openOutputStream(uri);\n                        byte[] buffer = new byte[8 * 1024];\n                        int bytes = sourceInputStream.read(buffer);\n                        while (bytes >= 0) {\n                            outputStream.write(buffer, 0, bytes);\n                            bytes = sourceInputStream.read(buffer);\n                        }\n                        outputStream.close();\n                    }\n                    sourceInputStream.close();\n                } catch (Exception ignored) {}\n\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    payload.putBoolean("success", true);\n                    payload.putBoolean("cancelled", false);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.resolve(true);\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n\n            @Override\n            public void onCancel() {\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    payload.putBoolean("success", false);\n                    payload.putBoolean("cancelled", true);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.resolve(false);\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n\n            @Override\n            public void onError(Exception error) {\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    WritableMap errorMap = Arguments.createMap();\n                    errorMap.putInt("code", 1234);\n                    errorMap.putString("message", error.getMessage());\n                    payload.putMap("error", errorMap);\n                    payload.putBoolean("success", false);\n                    payload.putBoolean("cancelled", false);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.reject("1234", error.getMessage());\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n        };\n    }\n// highlight-end\n\n// ...\n}\n')),(0,l.kt)("p",null,"For the promise block, we just resolve with boolean value or reject with an error.\nFor callback block, we want to create an object argument - to do that, let's use ",(0,l.kt)("inlineCode",{parentName:"p"},"Arguments.createMap")," utility helper."),(0,l.kt)("p",null,"The important thing and the main difference between Android & iOS implementation is that the Android's save file picker is actually only ",(0,l.kt)("em",{parentName:"p"},"creating")," a new empty file instead of copying the source file like on iOS.\nThat means, we have to manually copy the content of the requested file into the new location.\nIn our case, we are doing it in the listener's ",(0,l.kt)("inlineCode",{parentName:"p"},"onSuccess")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"'},"@Override\npublic void onSuccess(@Nullable Uri uri) {\n    try {\n        InputStream sourceInputStream = reactContext\n            .getApplicationContext()\n            .getAssets()\n            .open(sourceFilename);\n        if (uri != null) {\n            OutputStream outputStream = reactContext\n                .getContentResolver()\n                .openOutputStream(uri);\n            byte[] buffer = new byte[8 * 1024];\n            int bytes = sourceInputStream.read(buffer);\n            while (bytes >= 0) {\n                outputStream.write(buffer, 0, bytes);\n                bytes = sourceInputStream.read(buffer);\n            }\n            outputStream.close();\n        }\n        sourceInputStream.close();\n    } catch (Exception ignored) {}\n\n    // ...\n}\n")),(0,l.kt)("p",null,"That code takes specified file from application's assets directory, opens the file under the provided ",(0,l.kt)("inlineCode",{parentName:"p"},"uri")," and copies the content of the source file to the target file."),(0,l.kt)("p",null,"Last part is to use ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," class inside exported methods:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.java"'},"// ...\n\n/**\n * Declare Java class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\npublic class SaveFilePickerModule extends NativeSaveFilePickerModuleSpec {\n// ...\n\n    // Return the name of the module - it should match the name provided in JS specification\n    @Override\n    public String getName() {\n        return SaveFilePickerModuleImpl.NAME;\n    }\n\n// highlight-start\n    // Exported methods are overriden - based on the spec class\n    @Override\n    public void saveFileWithCallback(String filename, Callback callback) {\n        callbackBlock = callback;\n        sourceFilename = filename;\n        moduleImpl.saveFile(filename);\n    }\n\n    @Override\n    public void saveFileWithPromise(String filename, Promise promise) {\n        promiseBlock = promise;\n        sourceFilename = filename;\n        moduleImpl.saveFile(filename);\n    }\n// highlight-end\n}\n")),(0,l.kt)("p",null,"In the methods body, we save the callback/promise arguments and we use ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl#saveFile")," method to launch file activity picker."),(0,l.kt)(c.ZP,{filename:"SaveFilePickerModule.java",language:"java",mdxType:"CompleteFile"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'package com.savefilepickerpackage;\n\nimport android.net.Uri;\n\nimport androidx.annotation.Nullable;\n\nimport com.facebook.react.bridge.Arguments;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.Callback;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.module.annotations.ReactModule;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * Declare Java class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\npublic class SaveFilePickerModule extends NativeSaveFilePickerModuleSpec {\n    public static final String NAME = SaveFilePickerModuleImpl.NAME;\n\n    // Use shared module implementation and forward react application context\n    private final SaveFilePickerModuleImpl moduleImpl;\n\n    private @Nullable Callback callbackBlock = null;\n    private @Nullable Promise promiseBlock = null;\n    private String sourceFilename = "";\n\n    public SaveFilePickerModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n        this.moduleImpl = new SaveFilePickerModuleImpl(reactContext);\n        SaveFilePickerModuleImpl.listener = new SaveFilePickerModuleImpl.SaveFilePickerListener() {\n            @Override\n            public void onSuccess(@Nullable Uri uri) {\n                try {\n                    InputStream sourceInputStream = reactContext\n                        .getApplicationContext()\n                        .getAssets()\n                        .open(sourceFilename);\n                    if (uri != null) {\n                        OutputStream outputStream = reactContext\n                            .getContentResolver()\n                            .openOutputStream(uri);\n                        byte[] buffer = new byte[8 * 1024];\n                        int bytes = sourceInputStream.read(buffer);\n                        while (bytes >= 0) {\n                            outputStream.write(buffer, 0, bytes);\n                            bytes = sourceInputStream.read(buffer);\n                        }\n                        outputStream.close();\n                    }\n                    sourceInputStream.close();\n                } catch (Exception ignored) {}\n\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    payload.putBoolean("success", true);\n                    payload.putBoolean("cancelled", false);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.resolve(true);\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n\n            @Override\n            public void onCancel() {\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    payload.putBoolean("success", false);\n                    payload.putBoolean("cancelled", true);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.resolve(false);\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n\n            @Override\n            public void onError(Exception error) {\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    WritableMap errorMap = Arguments.createMap();\n                    errorMap.putInt("code", 1234);\n                    errorMap.putString("message", error.getMessage());\n                    payload.putMap("error", errorMap);\n                    payload.putBoolean("success", false);\n                    payload.putBoolean("cancelled", false);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.reject("1234", error.getMessage());\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n        };\n    }\n\n    // Return the name of the module - it should match the name provided in JS specification\n    @Override\n    public String getName() {\n        return SaveFilePickerModuleImpl.NAME;\n    }\n\n    // Exported methods are overriden - based on the spec class\n\n    @Override\n    public void saveFileWithCallback(String filename, Callback callback) {\n        callbackBlock = callback;\n        sourceFilename = filename;\n        moduleImpl.saveFile(filename);\n    }\n\n    @Override\n    public void saveFileWithPromise(String filename, Promise promise) {\n        promiseBlock = promise;\n        sourceFilename = filename;\n        moduleImpl.saveFile(filename);\n    }\n}\n'))),(0,l.kt)(s.ZP,{filename:"android/src/oldarch/java/com/savefilepickerpackage/SaveFilePickerModule.java",language:"java",mdxType:"OldArchAndroidModuleFile"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'package com.savefilepickerpackage;\n\nimport android.net.Uri;\n\nimport androidx.annotation.Nullable;\n\nimport com.facebook.react.bridge.Arguments;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Callback;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.module.annotations.ReactModule;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * Declare Java class for old arch native module implementation\n *\n * Each native module extends ReactContextBaseJavaModule class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\npublic class SaveFilePickerModule extends ReactContextBaseJavaModule {\n    public static final String NAME = SaveFilePickerModuleImpl.NAME;\n\n    // Use shared module implementation and forward react application context\n    private final SaveFilePickerModuleImpl moduleImpl;\n\n    private @Nullable Callback callbackBlock = null;\n    private @Nullable Promise promiseBlock = null;\n    private String sourceFilename = "";\n\n    public SaveFilePickerModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n        this.moduleImpl = new SaveFilePickerModuleImpl(reactContext);\n        SaveFilePickerModuleImpl.listener = new SaveFilePickerModuleImpl.SaveFilePickerListener() {\n            @Override\n            public void onSuccess(@Nullable Uri uri) {\n                try {\n                    InputStream sourceInputStream = reactContext\n                        .getApplicationContext()\n                        .getAssets()\n                        .open(sourceFilename);\n                    if (uri != null) {\n                        OutputStream outputStream = reactContext\n                            .getContentResolver()\n                            .openOutputStream(uri);\n                        byte[] buffer = new byte[8 * 1024];\n                        int bytes = sourceInputStream.read(buffer);\n                        while (bytes >= 0) {\n                            outputStream.write(buffer, 0, bytes);\n                            bytes = sourceInputStream.read(buffer);\n                        }\n                        outputStream.close();\n                    }\n                    sourceInputStream.close();\n                } catch (Exception ignored) {}\n\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    payload.putBoolean("success", true);\n                    payload.putBoolean("cancelled", false);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.resolve(true);\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n\n            @Override\n            public void onCancel() {\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    payload.putBoolean("success", false);\n                    payload.putBoolean("cancelled", true);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.resolve(false);\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n\n            @Override\n            public void onError(Exception error) {\n                Callback callback = callbackBlock;\n                Promise promise = promiseBlock;\n\n                if (callback != null) {\n                    WritableMap payload = Arguments.createMap();\n                    WritableMap errorMap = Arguments.createMap();\n                    errorMap.putInt("code", 1234);\n                    errorMap.putString("message", error.getMessage());\n                    payload.putMap("error", errorMap);\n                    payload.putBoolean("success", false);\n                    payload.putBoolean("cancelled", false);\n                    callback.invoke(payload);\n                } else if (promise != null) {\n                    promise.reject("1234", error.getMessage());\n                }\n\n                callbackBlock = null;\n                promiseBlock = null;\n                sourceFilename = "";\n            }\n        };\n    }\n\n    // Return the name of the module - it should match the name provided in JS specification\n    @Override\n    public String getName() {\n        return SaveFilePickerModuleImpl.NAME;\n    }\n\n    // Exported methods must be annotated with @ReactMethod decorator\n\n    @ReactMethod\n    public void saveFileWithCallback(String filename, Callback callback) {\n        callbackBlock = callback;\n        sourceFilename = filename;\n        moduleImpl.saveFile(filename);\n    }\n\n    @ReactMethod\n    public void saveFileWithPromise(String filename, Promise promise) {\n        promiseBlock = promise;\n        sourceFilename = filename;\n        moduleImpl.saveFile(filename);\n    }\n}\n'))),(0,l.kt)("p",null,"Let's finalize it by exporting the module in the ",(0,l.kt)("inlineCode",{parentName:"p"},"TurboReactPackage")," instance."))}d.isMDXComponent=!0;const m={toc:[{value:"<code>SaveFilePickerModuleImpl.java</code>",id:"savefilepickermoduleimpljava",level:4}]},k="wrapper";function v(e){let{components:n,...a}=e;return(0,l.kt)(k,(0,t.Z)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"savefilepickermoduleimpljava"},(0,l.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModuleImpl.java")),(0,l.kt)("p",null,"Let's start by creating a small pure Java class that will be responsible for launching platform save file picker:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/main/java/com/savefilepickerpackage/SaveFilePickerModuleImpl.java"',title:'"android/src/main/java/com/savefilepickerpackage/SaveFilePickerModuleImpl.java"'},'package com.savefilepickerpackage;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\n\nimport androidx.activity.result.ActivityResultLauncher;\nimport androidx.activity.result.contract.ActivityResultContracts;\nimport androidx.annotation.Nullable;\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport com.facebook.react.bridge.Callback;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.UiThreadUtil;\n\n/**\n * Native module\'s shared implementation\n */\npublic class SaveFilePickerModuleImpl {\n    interface SaveFilePickerListener {\n        void onSuccess(@Nullable Uri uri);\n        void onCancel();\n        void onError(Exception error);\n    }\n    private final ReactApplicationContext reactContext;\n    public static final String NAME = "SaveFilePickerModule";\n\n    private static @Nullable ActivityResultLauncher<Intent> activityLauncher = null;\n\n    public static @Nullable SaveFilePickerListener listener = null;\n\n    public static void registerActivityLauncher(AppCompatActivity activity) {\n        activityLauncher = activity.registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n            if (result.getResultCode() == Activity.RESULT_OK) {\n                if (listener != null) {\n                    Intent data = result.getData();\n                    Uri uri = null;\n                    if (data != null) {\n                        uri = data.getData();\n                    }\n                    listener.onSuccess(uri);\n                }\n            } else if (result.getResultCode() == Activity.RESULT_CANCELED) {\n                if (listener != null) {\n                    listener.onCancel();\n                }\n            } else {\n                if (listener != null) {\n                    listener.onError(new Exception("Unknown result when saving the file"));\n                }\n            }\n        });\n    }\n\n    public SaveFilePickerModuleImpl(ReactApplicationContext reactContext) {\n        this.reactContext = reactContext;\n    }\n\n    public void saveFile(String filename) {\n        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);\n        intent.addCategory(Intent.CATEGORY_OPENABLE);\n        intent.setType("text/html");\n        intent.putExtra(Intent.EXTRA_TITLE, filename);\n\n        ActivityResultLauncher<Intent> launcher = activityLauncher;\n        if (launcher == null) {\n            if (listener != null) {\n                listener.onError(new Exception("Activity launcher not registered"));\n            }\n            return;\n        }\n\n        UiThreadUtil.runOnUiThread(() -> {\n            launcher.launch(intent);\n        });\n    }\n}\n')),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"In this guide, we will be using generic ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.StartActivityForResult"},(0,l.kt)("inlineCode",{parentName:"a"},"ActivityResultContracts.StartActivityForResult"))," contract and raw intent action,\nto showcase, how to work with all possible types of actions.\nHowever, Android provides a set of standard contracts for popular actions (e.g. launching a camera, or requesting a permission),\nyou can visit ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts"},"Android docs")," to learn more.")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," is divided into 2 parts: static and non-static."),(0,l.kt)("p",null,"In the static part we will declare ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher"},(0,l.kt)("inlineCode",{parentName:"a"},"ActivityResultLauncher"))," variable that will be responsible for launching file activity picker and capturing picker's result.\nThe ",(0,l.kt)("inlineCode",{parentName:"p"},"registerActivityLauncher")," will take the activity as a parameter and invoke ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/androidx/activity/result/ActivityResultCaller#registerForActivityResult(androidx.activity.result.contract.ActivityResultContract%3CI,O%3E,androidx.activity.result.ActivityResultCallback%3CO%3E)"},(0,l.kt)("inlineCode",{parentName:"a"},"registerForActivityResult")),"\non that activity. The result callback will be invoked once the file activity picker will be closed and it will contain the uri of the file's destination.\nThat result will be then forwarded to the ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerListener")," instance."),(0,l.kt)("p",null,"Registering activity launcher will need to be done when the activity is started (typically in ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/android/app/Activity#onCreate(android.os.Bundle)"},(0,l.kt)("inlineCode",{parentName:"a"},"Activity#onCreate"))," method), we will do that later in the next steps."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"To learn more about communication between android activities, visit Android's ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/training/basics/intents/result"},'"Getting a result from an Activity"')," guide.")),(0,l.kt)("p",null,"The non-static part is a single method ",(0,l.kt)("inlineCode",{parentName:"p"},"saveFile")," that will be responsible just for invoking the ",(0,l.kt)("inlineCode",{parentName:"p"},"ActivityResultLauncher")," with the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/android/content/Intent#ACTION_CREATE_DOCUMENT"},(0,l.kt)("inlineCode",{parentName:"a"},"ACTION_CREATE_DOCUMENT"))," intent action.\nThe launcher needs to be used on the main/ui thread, so to do it, we will use ",(0,l.kt)("inlineCode",{parentName:"p"},"UiThreadUtil.runOnUiThread")," helper."),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},'For more on "save file" functionality visit Android ',(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/training/data-storage/shared/documents-files#create-file"},"docs"),".")))}v.isMDXComponent=!0;const h={toc:[]},b="wrapper";function f(e){let{components:n,...a}=e;return(0,l.kt)(b,(0,t.Z)({},h,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)(v,{mdxType:"AndroidJavaModuleImpl"}),(0,l.kt)(d,{mdxType:"AndroidJavaModule"}),(0,l.kt)(r.ZP,{language:"java",moduleClass:"SaveFilePickerModule",namespace:"savefilepickerpackage",packageClass:"SaveFilePickerTurboPackage",mdxType:"AndroidTurboPackage"}))}f.isMDXComponent=!0;const g={toc:[{value:"<code>SaveFilePickerModule.kt</code>",id:"savefilepickermodulekt",level:4}]},M="wrapper";function C(e){let{components:n,...a}=e;return(0,l.kt)(M,(0,t.Z)({},g,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"savefilepickermodulekt"},(0,l.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModule.kt")),(0,l.kt)("p",null,"Now, let's move to the module that will manage function calls from the JS world:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"'},"package com.savefilepickerpackage\n\nimport android.net.Uri\nimport com.facebook.react.bridge.Arguments\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.Callback\nimport com.facebook.react.bridge.Promise\nimport com.facebook.react.module.annotations.ReactModule\nimport java.io.File\n\n/**\n * Declare Kotlin class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\nclass SaveFilePickerModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : NativeSaveFilePickerModuleSpec(reactContext) {\n    // Use shared module implementation and forward react application context\n    private val moduleImpl = SaveFilePickerModuleImpl(reactContext)\n\n    // Return the name of the module - it should match the name provided in JS specification\n    override fun getName() = SaveFilePickerModuleImpl.NAME\n\n    // Exported methods are overriden - based on the spec class\n    override fun saveFileWithCallback(filename: String, callback: Callback) {\n        //\n    }\n\n    override fun saveFileWithPromise(filename: String, promise: Promise) {\n        //\n    }\n\n    companion object {\n        const val NAME = SaveFilePickerModuleImpl.NAME\n    }\n}\n")),(0,l.kt)("p",null,"Here we declare the ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," class.\nIt extends codegenerated spec class and takes ",(0,l.kt)("inlineCode",{parentName:"p"},"ReactApplicationContext")," instance as constructor parameter.\nAdditionally, ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," is annotated with ",(0,l.kt)("inlineCode",{parentName:"p"},"ReactModule")," decorator.\nStatic constant ",(0,l.kt)("inlineCode",{parentName:"p"},"NAME")," matches the value declared in JS specification."),(0,l.kt)("p",null,"For now, we start by adding empty implementations for methods declared in codegenerated spec class."),(0,l.kt)("p",null,"Now, let's add private variables for callback/promise blocks - we'll need to save them, once the exported methods are invoked and use, once there's result from the file activity picker."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"'},'// ...\n\n/**\n * Declare Kotlin class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\nclass SaveFilePickerModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : NativeSaveFilePickerModuleSpec(reactContext) {\n    // Use shared module implementation and forward react application context\n    private val moduleImpl = SaveFilePickerModuleImpl(reactContext)\n\n// highlight-start\n    private var callbackBlock: Callback? = null\n    private var promiseBlock: Promise? = null\n    private var sourceFilename: String = ""\n// highlight-end\n\n// ...\n}\n')),(0,l.kt)("p",null,"Next step is to implement listener object that will use callback/promise blocks to communicate the result to the JS code.\nWe will do it inside ",(0,l.kt)("inlineCode",{parentName:"p"},"init")," block:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"'},'// ...\n\n/**\n * Declare Kotlin class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\nclass SaveFilePickerModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : NativeSaveFilePickerModuleSpec(reactContext) {\n    // Use shared module implementation and forward react application context\n    private val moduleImpl = SaveFilePickerModuleImpl(reactContext)\n\n    private var callbackBlock: Callback? = null\n    private var promiseBlock: Promise? = null\n    private var sourceFilename: String = ""\n\n// highlight-start\n    init {\n        SaveFilePickerModuleImpl.listener = object : SaveFilePickerModuleImpl.SaveFilePickerListener {\n            override fun onCancel() {\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putBoolean("success", false)\n                        putBoolean("cancelled", true)\n                    })\n                } else if (promise != null) {\n                    promise.resolve(false)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n\n            override fun onError(error: Exception) {\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putMap("error", Arguments.createMap().apply {\n                            putInt("code", 1234)\n                            putString("message", error.message)\n                        })\n                        putBoolean("success", false)\n                        putBoolean("cancelled", false)\n                    })\n                } else if (promise != null) {\n                    promise.reject("1234", error.message)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n\n            override fun onSuccess(uri: Uri?) {\n                reactContext.applicationContext.assets.open(sourceFilename).use { sourceInputStream ->\n                    uri?.let {\n                        reactContext.contentResolver.openOutputStream(it)?.use { outputStream ->\n                            sourceInputStream.copyTo(outputStream)\n                        }\n                    }\n                }\n\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putBoolean("success", true)\n                        putBoolean("cancelled", false)\n                    })\n                } else if (promise != null) {\n                    promise.resolve(true)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n        }\n    }\n// highlight-end\n\n// ...\n}\n')),(0,l.kt)("p",null,"For the promise block, we just resolve with boolean value or reject with an error.\nFor callback block, we want to create an object argument - to do that, let's use ",(0,l.kt)("inlineCode",{parentName:"p"},"Arguments.createMap")," utility helper."),(0,l.kt)("p",null,"The important thing and the main difference between Android & iOS implementation is that the Android's save file picker is actually only ",(0,l.kt)("em",{parentName:"p"},"creating")," a new empty file instead of copying the source file like on iOS.\nThat means, we have to manually copy the content of the requested file into the new location.\nIn our case, we are doing it in the listener's ",(0,l.kt)("inlineCode",{parentName:"p"},"onSuccess")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"'},"override fun onSuccess(uri: Uri?) {\n    reactContext.applicationContext.assets.open(sourceFilename).use { sourceInputStream ->\n        uri?.let {\n            reactContext.contentResolver.openOutputStream(it)?.use { outputStream ->\n                sourceInputStream.copyTo(outputStream)\n            }\n        }\n    }\n\n    // ...\n}\n")),(0,l.kt)("p",null,"That code takes specified file from application's assets directory, opens the file under the provided ",(0,l.kt)("inlineCode",{parentName:"p"},"uri")," and copies the content of the source file to the target file."),(0,l.kt)("p",null,"Last part is to use ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," class inside exported methods:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"',title:'"android/src/newarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt"'},"// ...\n\n/**\n * Declare Kotlin class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = SaveFilePickerModule.NAME)\nclass SaveFilePickerModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : NativeSaveFilePickerModuleSpec(reactContext) {\n// ...\n\n    // Return the name of the module - it should match the name provided in JS specification\n    override fun getName() = SaveFilePickerModuleImpl.NAME\n\n// highlight-start\n    // Exported methods are overriden - based on the spec class\n    override fun saveFileWithCallback(filename: String, callback: Callback) {\n        callbackBlock = callback\n        sourceFilename = filename\n        moduleImpl.saveFile(filename)\n    }\n\n    override fun saveFileWithPromise(filename: String, promise: Promise) {\n        promiseBlock = promise\n        sourceFilename = filename\n        moduleImpl.saveFile(filename)\n    }\n// highlight-end\n\n    companion object {\n        const val NAME = SaveFilePickerModuleImpl.NAME\n    }\n}\n")),(0,l.kt)("p",null,"In the methods body, we save the callback/promise arguments and we use ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl#saveFile")," method to launch file activity picker."),(0,l.kt)(c.ZP,{filename:"SaveFilePickerModule.kt",language:"kotlin",mdxType:"CompleteFile"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'package com.savefilepickerpackage\n\nimport android.net.Uri\nimport com.facebook.react.bridge.Arguments\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.Callback\nimport com.facebook.react.bridge.Promise\nimport com.facebook.react.module.annotations.ReactModule\nimport java.io.File\n\n/**\n* Declare Kotlin class for new arch native module implementation\n*\n* Each turbo module extends codegenerated spec class\n*\n* Class should be annotated with @ReactModule decorator\n*/\n@ReactModule(name = SaveFilePickerModule.NAME)\nclass SaveFilePickerModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : NativeSaveFilePickerModuleSpec(reactContext) {\n    // Use shared module implementation and forward react application context\n    private val moduleImpl = SaveFilePickerModuleImpl(reactContext)\n\n    private var callbackBlock: Callback? = null\n    private var promiseBlock: Promise? = null\n    private var sourceFilename: String = ""\n\n    init {\n        SaveFilePickerModuleImpl.listener = object : SaveFilePickerModuleImpl.SaveFilePickerListener {\n            override fun onCancel() {\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putBoolean("success", false)\n                        putBoolean("cancelled", true)\n                    })\n                } else if (promise != null) {\n                    promise.resolve(false)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n\n            override fun onError(error: Exception) {\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putMap("error", Arguments.createMap().apply {\n                            putInt("code", 1234)\n                            putString("message", error.message)\n                        })\n                        putBoolean("success", false)\n                        putBoolean("cancelled", false)\n                    })\n                } else if (promise != null) {\n                    promise.reject("1234", error.message)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n\n            override fun onSuccess(uri: Uri?) {\n                reactContext.applicationContext.assets.open(sourceFilename).use { sourceInputStream ->\n                    uri?.let {\n                        reactContext.contentResolver.openOutputStream(it)?.use { outputStream ->\n                            sourceInputStream.copyTo(outputStream)\n                        }\n                    }\n                }\n\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putBoolean("success", true)\n                        putBoolean("cancelled", false)\n                    })\n                } else if (promise != null) {\n                    promise.resolve(true)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n        }\n    }\n\n    // Return the name of the module - it should match the name provided in JS specification\n    override fun getName() = SaveFilePickerModuleImpl.NAME\n\n    // Exported methods are overriden - based on the spec class\n    override fun saveFileWithCallback(filename: String, callback: Callback) {\n        callbackBlock = callback\n        sourceFilename = filename\n        moduleImpl.saveFile(filename)\n    }\n\n    override fun saveFileWithPromise(filename: String, promise: Promise) {\n        promiseBlock = promise\n        sourceFilename = filename\n        moduleImpl.saveFile(filename)\n    }\n\n    companion object {\n        const val NAME = SaveFilePickerModuleImpl.NAME\n    }\n}\n'))),(0,l.kt)(s.ZP,{filename:"android/src/oldarch/java/com/savefilepickerpackage/SaveFilePickerModule.kt",language:"kotlin",mdxType:"OldArchAndroidModuleFile"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'package com.savefilepickerpackage\n\nimport android.net.Uri\nimport com.facebook.react.bridge.Arguments\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\nimport com.facebook.react.bridge.Callback\nimport com.facebook.react.bridge.Promise\nimport com.facebook.react.module.annotations.ReactModule\nimport java.io.File\n\n/**\n* Declare Kotlin class for old arch native module implementation\n*\n* Each native module extends ReactContextBaseJavaModule class\n*\n* Class should be annotated with @ReactModule decorator\n*/\n@ReactModule(name = SaveFilePickerModule.NAME)\nclass SaveFilePickerModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : ReactContextBaseJavaModule(reactContext) {\n    // Use shared module implementation and forward react application context\n    private val moduleImpl = SaveFilePickerModuleImpl(reactContext)\n\n    private var callbackBlock: Callback? = null\n    private var promiseBlock: Promise? = null\n    private var sourceFilename: String = ""\n\n    init {\n        SaveFilePickerModuleImpl.listener = object : SaveFilePickerModuleImpl.SaveFilePickerListener {\n            override fun onCancel() {\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putBoolean("success", false)\n                        putBoolean("cancelled", true)\n                    })\n                } else if (promise != null) {\n                    promise.resolve(false)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n\n            override fun onError(error: Exception) {\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putMap("error", Arguments.createMap().apply {\n                            putInt("code", 1234)\n                            putString("message", error.message)\n                        })\n                        putBoolean("success", false)\n                        putBoolean("cancelled", false)\n                    })\n                } else if (promise != null) {\n                    promise.reject("1234", error.message)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n\n            override fun onSuccess(uri: Uri?) {\n                reactContext.applicationContext.assets.open(sourceFilename).use { sourceInputStream ->\n                    uri?.let {\n                        reactContext.contentResolver.openOutputStream(it)?.use { outputStream ->\n                            sourceInputStream.copyTo(outputStream)\n                        }\n                    }\n                }\n\n                val callback = callbackBlock\n                val promise = promiseBlock\n\n                if (callback != null) {\n                    callback.invoke(Arguments.createMap().apply {\n                        putBoolean("success", true)\n                        putBoolean("cancelled", false)\n                    })\n                } else if (promise != null) {\n                    promise.resolve(true)\n                }\n\n                callbackBlock = null\n                promiseBlock = null\n                sourceFilename = ""\n            }\n        }\n    }\n\n    // Return the name of the module - it should match the name provided in JS specification\n    override fun getName() = SaveFilePickerModuleImpl.NAME\n\n    // Exported methods must be annotated with @ReactMethod decorator\n    @ReactMethod\n    fun saveFileWithCallback(filename: String, callback: Callback) {\n        callbackBlock = callback\n        sourceFilename = filename\n        moduleImpl.saveFile(filename)\n    }\n\n    @ReactMethod\n    fun saveFileWithPromise(filename: String, promise: Promise) {\n        promiseBlock = promise\n        sourceFilename = filename\n        moduleImpl.saveFile(filename)\n    }\n\n    companion object {\n        const val NAME = SaveFilePickerModuleImpl.NAME\n    }\n}\n'))),(0,l.kt)("p",null,"Let's finalize it by exporting the module in the ",(0,l.kt)("inlineCode",{parentName:"p"},"TurboReactPackage")," instance."))}C.isMDXComponent=!0;const S={toc:[{value:"<code>SaveFilePickerModuleImpl.kt</code>",id:"savefilepickermoduleimplkt",level:4}]},y="wrapper";function x(e){let{components:n,...a}=e;return(0,l.kt)(y,(0,t.Z)({},S,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"savefilepickermoduleimplkt"},(0,l.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModuleImpl.kt")),(0,l.kt)("p",null,"Let's start by creating a small pure Kotlin class that will be responsible for launching platform save file picker:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/main/java/com/savefilepickerpackage/SaveFilePickerModuleImpl.kt"',title:'"android/src/main/java/com/savefilepickerpackage/SaveFilePickerModuleImpl.kt"'},'package com.savefilepickerpackage\n\nimport android.app.Activity\nimport android.content.Intent\nimport android.net.Uri\nimport androidx.activity.result.ActivityResultLauncher\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.appcompat.app.AppCompatActivity\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.UiThreadUtil\n\n/**\n * Native module\'s shared implementation\n */\nclass SaveFilePickerModuleImpl(private val reactContext: ReactApplicationContext) {\n    fun saveFile(filename: String) {\n        val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply {\n            addCategory(Intent.CATEGORY_OPENABLE)\n            type = "text/html"\n            putExtra(Intent.EXTRA_TITLE, filename)\n        }\n\n        val launcher = activityLauncher\n        if (launcher == null) {\n            listener?.onError(Exception("Activity launcher not registered"))\n            return\n        }\n\n        UiThreadUtil.runOnUiThread {\n            launcher.launch(intent)\n        }\n    }\n\n    interface SaveFilePickerListener {\n        fun onSuccess(uri: Uri?)\n        fun onCancel()\n        fun onError(error: Exception)\n    }\n\n    companion object {\n        const val NAME = "SaveFilePickerModule"\n\n        private var activityLauncher: ActivityResultLauncher<Intent>? = null\n\n        var listener: SaveFilePickerListener? = null\n\n        fun registerActivityLauncher(activity: AppCompatActivity) {\n            activityLauncher = activity.registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->\n                when (result.resultCode) {\n                    Activity.RESULT_OK -> {\n                        listener?.onSuccess(result.data?.data)\n                    }\n                    Activity.RESULT_CANCELED -> {\n                        listener?.onCancel()\n                    }\n                    else -> {\n                        listener?.onError(Exception("Unknown result when saving the file"))\n                    }\n                }\n            }\n        }\n    }\n}\n')),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"In this guide, we will be using generic ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/kotlin/androidx/activity/result/contract/ActivityResultContracts.StartActivityForResult"},(0,l.kt)("inlineCode",{parentName:"a"},"ActivityResultContracts.StartActivityForResult"))," contract and raw intent action,\nto showcase how to work with all possible types of actions.\nHowever, Android provides a set of standard contracts for popular actions (e.g. launching a camera, or requesting a permission),\nyou can visit ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/kotlin/androidx/activity/result/contract/ActivityResultContracts"},"Android docs")," to learn more.")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," is divided into 2 parts: static and non-static."),(0,l.kt)("p",null,"In the static part we will declare ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/kotlin/androidx/activity/result/ActivityResultLauncher"},(0,l.kt)("inlineCode",{parentName:"a"},"ActivityResultLauncher"))," variable that will be responsible for launching file activity picker and capturing picker's result.\nThe ",(0,l.kt)("inlineCode",{parentName:"p"},"registerActivityLauncher")," will take the activity as a parameter and invoke ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/kotlin/androidx/activity/result/ActivityResultCaller#registerForActivityResult(androidx.activity.result.contract.ActivityResultContract%3CI,O%3E,androidx.activity.result.ActivityResultCallback%3CO%3E)"},(0,l.kt)("inlineCode",{parentName:"a"},"registerForActivityResult")),"\non that activity. The result callback will be invoked once the file activity picker will be closed and it will contain the uri of the file's destination.\nThat result will be then forwarded to the ",(0,l.kt)("inlineCode",{parentName:"p"},"SaveFilePickerListener")," instance."),(0,l.kt)("p",null,"Registering activity launcher will need to be done when the activity is started (typically in ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/kotlin/android/app/Activity#oncreate"},(0,l.kt)("inlineCode",{parentName:"a"},"Activity#onCreate"))," method), we will do that later in the next steps."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"To learn more about communication between android activities, visit Android's ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/training/basics/intents/result"},'"Getting a result from an Activity"')," guide.")),(0,l.kt)("p",null,"The non-static part is a single method ",(0,l.kt)("inlineCode",{parentName:"p"},"saveFile")," that will be responsible just for invoking the ",(0,l.kt)("inlineCode",{parentName:"p"},"ActivityResultLauncher")," with the ",(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/kotlin/android/content/Intent#action_create_document"},(0,l.kt)("inlineCode",{parentName:"a"},"ACTION_CREATE_DOCUMENT"))," intent action.\nThe launcher needs to be used on the main/ui thread, so to do it, we will use ",(0,l.kt)("inlineCode",{parentName:"p"},"UiThreadUtil.runOnUiThread")," helper."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},'For more on "save file" functionality visit Android ',(0,l.kt)("a",{parentName:"p",href:"https://developer.android.com/training/data-storage/shared/documents-files#create-file"},"docs"),".")))}x.isMDXComponent=!0;const F={toc:[]},w="wrapper";function A(e){let{components:n,...a}=e;return(0,l.kt)(w,(0,t.Z)({},F,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)(x,{mdxType:"AndroidKotlinModuleImpl"}),(0,l.kt)(C,{mdxType:"AndroidKotlinModule"}),(0,l.kt)(r.ZP,{language:"kotlin",moduleClass:"SaveFilePickerModule",namespace:"savefilepickerpackage",packageClass:"SaveFilePickerTurboPackage",mdxType:"AndroidTurboPackage"}))}A.isMDXComponent=!0;const N={toc:[{value:"Register activity launcher",id:"register-activity-launcher",level:4}]},P="wrapper";function I(e){let{components:n,...a}=e;return(0,l.kt)(P,(0,t.Z)({},N,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"register-activity-launcher"},"Register activity launcher"),(0,l.kt)("p",null,"We have completed the implementation of the Android part.\nHowever, there's one specific manual step that we need to do for this kind of module and that is registering the activity launcher inside the app's main activity."),(0,l.kt)(i.Z,{groupId:"android_lang",mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/app/src/main/java/com/rnbridgingtutorial/MainActivity.kt"',title:'"android/app/src/main/java/com/rnbridgingtutorial/MainActivity.kt"'},'// highlight-start\nimport com.savefilepickerpackage.SaveFilePickerModuleImpl // add this import\n// highlight-end\n\nclass MainActivity : ReactActivity() {\n\n    /**\n     * Returns the name of the main component registered from JavaScript. This is used to schedule\n     * rendering of the component.\n     */\n    override fun getMainComponentName(): String {\n        return "rnbridgingtutorial"\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n// highlight-start\n        SaveFilePickerModuleImpl.registerActivityLauncher(this) // add this line\n// highlight-end\n    }\n\n    // ...\n}\n'))),(0,l.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/app/src/main/java/com/rnbridgingtutorial/MainActivity.java"',title:'"android/app/src/main/java/com/rnbridgingtutorial/MainActivity.java"'},'// highlight-start\nimport com.savefilepickerpackage.SaveFilePickerModuleImpl; // add this import\n// highlight-end\n\npublic class MainActivity extends ReactActivity {\n\n    /**\n     * Returns the name of the main component registered from JavaScript. This is used to schedule\n     * rendering of the component.\n     */\n    @Override\n    public String getMainComponentName() {\n        return "rnbridgingtutorial";\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n// highlight-start\n        SaveFilePickerModuleImpl.registerActivityLauncher(this); // add this line\n// highlight-end\n    }\n\n    // ...\n}\n')))),(0,l.kt)("p",null,"In our test Android app, inside ",(0,l.kt)("inlineCode",{parentName:"p"},"MainActivity")," class we are registering the activity launcher.\nWithout that, our module wouldn't be able to launch another activities."))}I.isMDXComponent=!0;const R={sidebar_label:"Android implementation",sidebar_position:5,title:"Android implementation"},E=void 0,B={unversionedId:"guides/save-file-picker-module/android-impl",id:"guides/save-file-picker-module/android-impl",title:"Android implementation",description:"Let's use Android Studio for writing Android code. Launch Android Studio and open the project under /android path.",source:"@site/docs/guides/save-file-picker-module/android-impl.mdx",sourceDirName:"guides/save-file-picker-module",slug:"/guides/save-file-picker-module/android-impl",permalink:"/rnbridgingtutorial/docs/guides/save-file-picker-module/android-impl",draft:!1,editUrl:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/docs/docs/guides/save-file-picker-module/android-impl.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_label:"Android implementation",sidebar_position:5,title:"Android implementation"},sidebar:"tutorialSidebar",previous:{title:"iOS implementation",permalink:"/rnbridgingtutorial/docs/guides/save-file-picker-module/ios-impl"},next:{title:"Usage in practice",permalink:"/rnbridgingtutorial/docs/guides/save-file-picker-module/usage"}},T={},j=[],L={toc:j},O="wrapper";function U(e){let{components:n,...a}=e;return(0,l.kt)(O,(0,t.Z)({},L,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Let's use Android Studio for writing Android code. Launch Android Studio and open the project under ",(0,l.kt)("inlineCode",{parentName:"p"},"<your-project-dir>/android")," path.\nWhen the project is opened, find ",(0,l.kt)("inlineCode",{parentName:"p"},"save-file-picker-package")," inside project-tree"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"save-file-picker-package")," contains 3 packages with the same name ",(0,l.kt)("inlineCode",{parentName:"p"},"com.savefilepickerpackage"),". After expanding them, you'll notice that these contain following things:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"code-generated Java spec files"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"SaveFilePickerModule")," class stub files"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"SaveFilePickerModuleImpl")," class stub file"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"SaveFilePickerTurboPackage")," class stub file")),(0,l.kt)("p",null,"Let's start implementing!"),(0,l.kt)(i.Z,{groupId:"android_lang",mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)(A,{mdxType:"AndroidKotlinImpl"})),(0,l.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)(f,{mdxType:"AndroidJavaImpl"}))),(0,l.kt)(I,{mdxType:"AndroidRegisterActivityLauncher"}),(0,l.kt)("p",null,"You can check training repo for Kotlin implementation ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/save-file-picker-package"},"here")," and Java implementation ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/save-file-picker-package-classic"},"here"),"."),(0,l.kt)("p",null,"That's Android part, now let's wrap things up and try to use save file picker module in action!"))}U.isMDXComponent=!0}}]);