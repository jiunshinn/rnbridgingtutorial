"use strict";(self.webpackChunkbridging_tutorial_website=self.webpackChunkbridging_tutorial_website||[]).push([[888],{5162:(e,n,i)=>{i.d(n,{Z:()=>l});var t=i(7294),a=i(6010);const r={tabItem:"tabItem_Ymn6"};function l(e){let{children:n,hidden:i,className:l}=e;return t.createElement("div",{role:"tabpanel",className:(0,a.Z)(r.tabItem,l),hidden:i},n)}},4866:(e,n,i)=>{i.d(n,{Z:()=>v});var t=i(7462),a=i(7294),r=i(6010),l=i(2466),o=i(6550),d=i(1980),s=i(7392),p=i(12);function c(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:i,attributes:t,default:a}}=e;return{value:n,label:i,attributes:t,default:a}}))}function g(e){const{values:n,children:i}=e;return(0,a.useMemo)((()=>{const e=n??c(i);return function(e){const n=(0,s.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function m(e){let{value:n,tabValues:i}=e;return i.some((e=>e.value===n))}function u(e){let{queryString:n=!1,groupId:i}=e;const t=(0,o.k6)(),r=function(e){let{queryString:n=!1,groupId:i}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:n,groupId:i});return[(0,d._X)(r),(0,a.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})}),[r,t])]}function w(e){const{defaultValue:n,queryString:i=!1,groupId:t}=e,r=g(e),[l,o]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=i.find((e=>e.default))??i[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r}))),[d,s]=u({queryString:i,groupId:t}),[c,w]=function(e){let{groupId:n}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(n),[t,r]=(0,p.Nk)(i);return[t,(0,a.useCallback)((e=>{i&&r.set(e)}),[i,r])]}({groupId:t}),V=(()=>{const e=d??c;return m({value:e,tabValues:r})?e:null})();(0,a.useLayoutEffect)((()=>{V&&o(V)}),[V]);return{selectedValue:l,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),s(e),w(e)}),[s,w,r]),tabValues:r}}var V=i(2389);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:n,block:i,selectedValue:o,selectValue:d,tabValues:s}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.o5)(),g=e=>{const n=e.currentTarget,i=p.indexOf(n),t=s[i].value;t!==o&&(c(n),d(t))},m=e=>{let n=null;switch(e.key){case"Enter":g(e);break;case"ArrowRight":{const i=p.indexOf(e.currentTarget)+1;n=p[i]??p[0];break}case"ArrowLeft":{const i=p.indexOf(e.currentTarget)-1;n=p[i]??p[p.length-1];break}}n?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":i},n)},s.map((e=>{let{value:n,label:i,attributes:l}=e;return a.createElement("li",(0,t.Z)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:e=>p.push(e),onKeyDown:m,onClick:g},l,{className:(0,r.Z)("tabs__item",h.tabItem,l?.className,{"tabs__item--active":o===n})}),i??n)})))}function S(e){let{lazy:n,children:i,selectedValue:t}=e;if(i=Array.isArray(i)?i:[i],n){const e=i.find((e=>e.props.value===t));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t}))))}function R(e){const n=w(e);return a.createElement("div",{className:(0,r.Z)("tabs-container",h.tabList)},a.createElement(b,(0,t.Z)({},e,n)),a.createElement(S,(0,t.Z)({},e,n)))}function v(e){const n=(0,V.Z)();return a.createElement(R,(0,t.Z)({key:String(n)},e))}},6162:(e,n,i)=>{i.d(n,{ZP:()=>d});var t=i(7462),a=(i(7294),i(3905)),r=i(814);const l={toc:[]},o="wrapper";function d(e){let{components:n,...i}=e;return(0,a.kt)(o,(0,t.Z)({},l,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Complete ",(0,a.kt)("code",null,i.filename)," file"),(0,a.kt)("div",null,(0,a.kt)(r.Z,{language:i.language,mdxType:"CodeBlock"},i.children))))}d.isMDXComponent=!0},5403:(e,n,i)=>{i.d(n,{ZP:()=>o});var t=i(7462),a=(i(7294),i(3905));const r={toc:[]},l="wrapper";function o(e){let{components:n,...i}=e;return(0,a.kt)(l,(0,t.Z)({},r,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"To make Swift elements accessible to Objective-C world, we have to do 4 things:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"make class extending ",(0,a.kt)("inlineCode",{parentName:"li"},"NSObject")),(0,a.kt)("li",{parentName:"ul"},"mark class and its methods (at least those methods that are meant to be exposed) as public"),(0,a.kt)("li",{parentName:"ul"},"mark class with ",(0,a.kt)("inlineCode",{parentName:"li"},"@objc(exported-objc-name)")," decorator"),(0,a.kt)("li",{parentName:"ul"},"mark exposed methods with ",(0,a.kt)("inlineCode",{parentName:"li"},"@objc")," decorator"))))}o.isMDXComponent=!0},8740:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>F,contentTitle:()=>M,default:()=>G,frontMatter:()=>A,metadata:()=>L,toc:()=>B});var t=i(7462),a=(i(7294),i(3905)),r=i(4866),l=i(5162);const o={toc:[{value:"Add native library as dependency for the package",id:"add-native-library-as-dependency-for-the-package",level:4}]},d="wrapper";function s(e){let{components:n,...i}=e;return(0,a.kt)(d,(0,t.Z)({},o,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"add-native-library-as-dependency-for-the-package"},"Add native library as dependency for the package"),(0,a.kt)("p",null,"When developing some native code, you might end up in a need to add some iOS library.\nEach RN library that includes some iOS native code is integrated to your project thanks to ",(0,a.kt)("a",{parentName:"p",href:"https://cocoapods.org/"},"CocoaPods"),".\nAnd that's also the case for our module - we have ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeSliderPackage.podspec"),", so let's navigate there and add a native dependency."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff",metastring:'title="RangeSliderPackage.podspec"',title:'"RangeSliderPackage.podspec"'},'# `.podspec` file is like "`package.json`" for iOS CocoaPods packages\n\nrequire "json"\n\npackage = JSON.parse(File.read(File.join(__dir__, "package.json")))\n\n# Detect if new arch is enabled\nfabric_enabled = ENV[\'RCT_NEW_ARCH_ENABLED\'] == \'1\'\n\nPod::Spec.new do |s|\n  s.name            = "RangeSliderPackage"\n  s.version         = package["version"]\n  s.summary         = package["description"]\n  s.description     = package["description"]\n  s.homepage        = package["homepage"]\n  s.license         = package["license"]\n  s.platforms       = { :ios => "13.0" }\n  s.author          = package["author"]\n  s.source          = { :git => package["repository"], :tag => "#{s.version}" }\n\n  # This is crucial - declare which files will be included in the package (similar to "files" field in `package.json`)\n  s.source_files    = "ios/**/*.{h,m,mm,swift}"\n  # Declare dependency (similar to entries under "dependencies" field in `package.json`)\n  s.dependency "React-Core"\n+\n+ s.dependency \'RangeUISlider\', \'~> 3.0\'\n\n  # More configuration depending on new or old arch used\n  if fabric_enabled\n    # Some compiler flags\n    folly_compiler_flags = \'-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1 -Wno-comma -Wno-shorten-64-to-32\'\n\n    s.compiler_flags = folly_compiler_flags + " -DRCT_NEW_ARCH_ENABLED=1"\n    # XCode flags for new arch\n    s.pod_target_xcconfig    = {\n      "HEADER_SEARCH_PATHS" => "\\"$(PODS_ROOT)/boost\\"",\n      "OTHER_CPLUSPLUSFLAGS" => "-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1",\n      "CLANG_CXX_LANGUAGE_STANDARD" => "c++17",\n      "DEFINES_MODULE" => "YES",\n      "SWIFT_OBJC_INTERFACE_HEADER_NAME" => "RangeSliderPackage-Swift.h",\n      # This is handy when we want to detect if new arch is enabled in Swift code\n      # and can be used like:\n      # #if RANGE_SLIDER_PACKAGE_NEW_ARCH_ENABLED\n      # // do sth when new arch is enabled\n      # #else\n      # // do sth when old arch is enabled\n      # #endif\n      "OTHER_SWIFT_FLAGS" => "-DRANGE_SLIDER_PACKAGE_NEW_ARCH_ENABLED"\n    }\n\n    # Dependencies only for new arch\n    s.dependency "React-Codegen"\n    s.dependency "RCT-Folly"\n    s.dependency "RCTRequired"\n    s.dependency "RCTTypeSafety"\n    s.dependency "ReactCommon/turbomodule/core"\n  else\n    # XCode flags for old arch\n    s.pod_target_xcconfig = {\n      "DEFINES_MODULE" => "YES",\n      "SWIFT_OBJC_INTERFACE_HEADER_NAME" => "RangeSliderPackage-Swift.h"\n    }\n  end\nend\n')),(0,a.kt)("p",null,"For the range slider view we will use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/chicio/RangeUISlider"},(0,a.kt)("inlineCode",{parentName:"a"},"RangeUISlider")," library"),".\nTo declare the dependency in the podspec, we add ",(0,a.kt)("inlineCode",{parentName:"p"},'s.dependency "<name of the native library>"')," - in this case it's ",(0,a.kt)("inlineCode",{parentName:"p"},"s.dependency 'RangeUISlider', '~> 3.0'"),"."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"'~> 3.0'")," syntax in the podspec is kind of similar to declaring some JS dependency in package.json with version ",(0,a.kt)("inlineCode",{parentName:"p"},'"^3"')," - so the version needs to be at least ",(0,a.kt)("inlineCode",{parentName:"p"},"3.0.0"),", but less than ",(0,a.kt)("inlineCode",{parentName:"p"},"4.0.0"))),(0,a.kt)("p",null,"After that, you can run ",(0,a.kt)("inlineCode",{parentName:"p"},"npx pod-install")," from your app's directory and library should be installed."))}s.isMDXComponent=!0;var p=i(6162);const c={toc:[{value:"<code>RangeSliderViewComponentView.h</code>",id:"rangesliderviewcomponentviewh",level:4},{value:"<code>RangeSliderViewComponentView.mm</code>",id:"rangesliderviewcomponentviewmm",level:4}]},g="wrapper";function m(e){let{components:n,...i}=e;return(0,a.kt)(g,(0,t.Z)({},c,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"rangesliderviewcomponentviewh"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewComponentView.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.h"',title:'"ios/RangeSliderViewComponentView.h"'},"#if RCT_NEW_ARCH_ENABLED\n#import <React/RCTViewComponentView.h>\n\n@interface RangeSliderViewComponentView : RCTViewComponentView\n\n@end\n\n#endif\n")),(0,a.kt)("p",null,"Nothing fancy here, Fabric component view extending base ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTViewComponentView")," class."),(0,a.kt)("h4",{id:"rangesliderviewcomponentviewmm"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewComponentView.mm")),(0,a.kt)("p",null,"The implementation for the Fabric component will be quite large, so let's try to break it into parts."),(0,a.kt)("p",null,"The first part - boilerplate:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.mm"',title:'"ios/RangeSliderViewComponentView.mm"'},'#if RCT_NEW_ARCH_ENABLED\n#import "RangeSliderViewComponentView.h"\n\n#import <React/RCTConversions.h>\n\n#import <react/renderer/components/RangeSliderPackage/ComponentDescriptors.h>\n#import <react/renderer/components/RangeSliderPackage/EventEmitters.h>\n#import <react/renderer/components/RangeSliderPackage/Props.h>\n#import <react/renderer/components/RangeSliderPackage/RCTComponentViewHelpers.h>\n\n#import "RCTFabricComponentsPlugins.h"\n\nusing namespace facebook::react;\n\n@interface RangeSliderViewComponentView () <RCTRangeSliderViewViewProtocol>\n@end\n\n@implementation RangeSliderViewComponentView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        static const auto defaultProps = std::make_shared<const RangeSliderViewProps>();\n        _props = defaultProps;\n    }\n\n    return self;\n}\n\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n    const auto &oldViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(_props);\n    const auto &newViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(props);\n\n    [super updateProps:props oldProps:oldProps];\n}\n\n- (void)mountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)unmountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args\n{\n    RCTRangeSliderViewHandleCommand(self, commandName, args);\n}\n\n- (void)setLeftKnobValueProgrammatically:(double)value\n{\n    //\n}\n\n- (void)setRightKnobValueProgrammatically:(double)value\n{\n    //\n}\n\n+ (ComponentDescriptorProvider)componentDescriptorProvider\n{\n    return concreteComponentDescriptorProvider<RangeSliderViewComponentDescriptor>();\n}\n\n@end\n\nClass<RCTComponentViewProtocol> RangeSliderViewCls(void)\n{\n    return RangeSliderViewComponentView.class;\n}\n#endif\n')),(0,a.kt)("p",null,"Component begins with some new arch imports and conversion helpers."),(0,a.kt)("p",null,"We make the component extending code-generated protocol - this protocol has all the native commands methods that we declared in JS spec."),(0,a.kt)("p",null,"Next we implement all required methods and we create ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeSliderViewCls")," function."),(0,a.kt)("p",null,"If you take a closer look, we override two methods related to the child components (",(0,a.kt)("inlineCode",{parentName:"p"},"- mountChildComponentView:index:")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"- unmountChildComponentView:index:"),").\nThose methods can be used to control how the child views should be added/removed in the Fabric component.\nIn our case, we prevent adding/removal to be sure that our slider view does not have any child views."),(0,a.kt)("p",null,"Another interesting thing takes place in ",(0,a.kt)("inlineCode",{parentName:"p"},"- handleCommand:args:")," method - it invokes ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTRangeSliderViewHandleCommand")," function.\nThat function is code-generated as well as ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTRangeSliderViewViewProtocol")," protocol and is used to forward native commands calls, to dedicated methods (in our case: ",(0,a.kt)("inlineCode",{parentName:"p"},"- setLeftKnobValueProgrammatically")," & ",(0,a.kt)("inlineCode",{parentName:"p"},"- setRightKnobValueProgrammatically"),")."),(0,a.kt)("p",null,"OK - second part, let's start filling the boilerplate with our slider view:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.mm"',title:'"ios/RangeSliderViewComponentView.mm"'},'// ...\n\n// highlight-start\n#import "RangeSliderView.h"\n// highlight-end\n\nusing namespace facebook::react;\n\n@interface RangeSliderViewComponentView () <RCTRangeSliderViewViewProtocol>\n@end\n\n// highlight-start\n@interface RangeSliderViewComponentView () <RangeSliderViewDelegate>\n@end\n// highlight-end\n\n@implementation RangeSliderViewComponentView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        static const auto defaultProps = std::make_shared<const RangeSliderViewProps>();\n        _props = defaultProps;\n\n// highlight-start\n        RangeSliderView *view = [RangeSliderView new];\n        view.delegate = self;\n\n        self.contentView = (UIView *)view;\n// highlight-end\n    }\n\n    return self;\n}\n\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n    const auto &oldViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(_props);\n    const auto &newViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(props);\n\n// highlight-start\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n\n    if (oldViewProps.activeColor != newViewProps.activeColor) {\n        [view setActiveColor:RCTUIColorFromSharedColor(newViewProps.activeColor)];\n    }\n    \n    if (oldViewProps.inactiveColor != newViewProps.inactiveColor) {\n        [view setInactiveColor:RCTUIColorFromSharedColor(newViewProps.inactiveColor)];\n    }\n\n    if (oldViewProps.step != newViewProps.step) {\n        [view setStep:newViewProps.step];\n    }\n    \n    if (oldViewProps.minValue != newViewProps.minValue) {\n        [view setMinValue:newViewProps.minValue];\n    }\n    \n    if (oldViewProps.maxValue != newViewProps.maxValue) {\n        [view setMaxValue:newViewProps.maxValue];\n    }\n    \n    if (oldViewProps.leftKnobValue != newViewProps.leftKnobValue) {\n        [view setLeftKnobValue:newViewProps.leftKnobValue];\n    }\n    \n    if (oldViewProps.rightKnobValue != newViewProps.rightKnobValue) {\n        [view setRightKnobValue:newViewProps.rightKnobValue];\n    }\n// highlight-end\n\n    [super updateProps:props oldProps:oldProps];\n}\n\n// ...\n\n@end\n\n// ...\n')),(0,a.kt)("p",null,"What's going on here?"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderView")," is imported"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderViewDelegate")," is implemented by the Fabric component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderView")," is initialized and set as a ",(0,a.kt)("inlineCode",{parentName:"li"},"contentView"),", its delegate is set to this Fabric component's instance"),(0,a.kt)("li",{parentName:"ul"},"all props are handled in ",(0,a.kt)("inlineCode",{parentName:"li"},"- updateProps:oldProps:"))),(0,a.kt)("p",null,"But that's still only half of the things - XCode is probably warning you that ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeSliderViewDelegate")," is not implemented - let's fix it!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.mm"',title:'"ios/RangeSliderViewComponentView.mm"'},"// ...\n\n@implementation RangeSliderViewComponentView\n\n// ...\n\n// highlight-start\n- (void)sendOnRangeSliderViewValueChangeEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewValueChange(\n                RangeSliderViewEventEmitter::OnRangeSliderViewValueChange{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n\n- (void)sendOnRangeSliderViewBeginDragEvent\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewBeginDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewBeginDrag{});\n    }\n}\n\n- (void)sendOnRangeSliderViewEndDragEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewEndDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewEndDrag{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n// highlight-end\n\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args\n{\n    RCTRangeSliderViewHandleCommand(self, commandName, args);\n}\n\n// highlight-start\n- (void)setLeftKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setLeftKnobValue:value];\n}\n\n- (void)setRightKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setRightKnobValue:value];\n}\n// highlight-end\n\n// ...\n\n@end\n\n// ...\n")),(0,a.kt)("p",null,"So now all warnings should be cleared - delegate methods are implemented and we also handled native commands."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Event emitters in new architecture mode are done in C++ and are code-generated")),(0,a.kt)(p.ZP,{filename:"RangeSliderViewComponentView.mm",language:"objc",mdxType:"CompleteFile"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'#if RCT_NEW_ARCH_ENABLED\n#import "RangeSliderViewComponentView.h"\n\n#import <React/RCTConversions.h>\n\n#import <react/renderer/components/RangeSliderPackage/ComponentDescriptors.h>\n#import <react/renderer/components/RangeSliderPackage/EventEmitters.h>\n#import <react/renderer/components/RangeSliderPackage/Props.h>\n#import <react/renderer/components/RangeSliderPackage/RCTComponentViewHelpers.h>\n\n#import "RCTFabricComponentsPlugins.h"\n\n#import "RangeSliderView.h"\n\nusing namespace facebook::react;\n\n@interface RangeSliderViewComponentView () <RCTRangeSliderViewViewProtocol>\n@end\n\n@interface RangeSliderViewComponentView () <RangeSliderViewDelegate>\n@end\n\n@implementation RangeSliderViewComponentView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        static const auto defaultProps = std::make_shared<const RangeSliderViewProps>();\n        _props = defaultProps;\n\n        RangeSliderView *view = [RangeSliderView new];\n        view.delegate = self;\n\n        self.contentView = (UIView *)view;\n    }\n\n    return self;\n}\n\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n    const auto &oldViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(_props);\n    const auto &newViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(props);\n\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n\n    if (oldViewProps.activeColor != newViewProps.activeColor) {\n        [view setActiveColor:RCTUIColorFromSharedColor(newViewProps.activeColor)];\n    }\n    \n    if (oldViewProps.inactiveColor != newViewProps.inactiveColor) {\n        [view setInactiveColor:RCTUIColorFromSharedColor(newViewProps.inactiveColor)];\n    }\n\n    if (oldViewProps.step != newViewProps.step) {\n        [view setStep:newViewProps.step];\n    }\n    \n    if (oldViewProps.minValue != newViewProps.minValue) {\n        [view setMinValue:newViewProps.minValue];\n    }\n    \n    if (oldViewProps.maxValue != newViewProps.maxValue) {\n        [view setMaxValue:newViewProps.maxValue];\n    }\n    \n    if (oldViewProps.leftKnobValue != newViewProps.leftKnobValue) {\n        [view setLeftKnobValue:newViewProps.leftKnobValue];\n    }\n    \n    if (oldViewProps.rightKnobValue != newViewProps.rightKnobValue) {\n        [view setRightKnobValue:newViewProps.rightKnobValue];\n    }\n\n    [super updateProps:props oldProps:oldProps];\n}\n\n- (void)mountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)unmountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)sendOnRangeSliderViewValueChangeEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewValueChange(\n                RangeSliderViewEventEmitter::OnRangeSliderViewValueChange{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n\n- (void)sendOnRangeSliderViewBeginDragEvent\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewBeginDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewBeginDrag{});\n    }\n}\n\n- (void)sendOnRangeSliderViewEndDragEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewEndDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewEndDrag{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args\n{\n    RCTRangeSliderViewHandleCommand(self, commandName, args);\n}\n\n- (void)setLeftKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setLeftKnobValue:value];\n}\n\n- (void)setRightKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setRightKnobValue:value];\n}\n\n+ (ComponentDescriptorProvider)componentDescriptorProvider\n{\n    return concreteComponentDescriptorProvider<RangeSliderViewComponentDescriptor>();\n}\n\n@end\n\nClass<RCTComponentViewProtocol> RangeSliderViewCls(void)\n{\n    return RangeSliderViewComponentView.class;\n}\n#endif\n'))))}m.isMDXComponent=!0;var u=i(5403);const w={toc:[{value:"Exposing Swift only library to Objective-C",id:"exposing-swift-only-library-to-objective-c",level:4}]},V="wrapper";function h(e){let{components:n,...i}=e;return(0,a.kt)(V,(0,t.Z)({},w,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"exposing-swift-only-library-to-objective-c"},"Exposing Swift only library to Objective-C"),(0,a.kt)("p",null,"Sometimes you may have to use some Swift-only libraries and sooner or later, you'll have to use them in Objective-C code."),(0,a.kt)("p",null,"In our case, we need to somehow use our slider library in Objective-C view code.\nTo do that we will create small Swift wrapper class that will expose functionality we need."),(0,a.kt)("p",null,"Let's start by creating our slider with some default configuration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},"import RangeUISlider\nimport UIKit\n\nclass RangeUISliderObject {\n    public var slider: RangeUISlider = {\n        let rangeSlider = RangeUISlider()\n        rangeSlider.barCorners = 5\n        rangeSlider.barHeight = 10\n        rangeSlider.leftKnobColor = UIColor.systemBlue\n        rangeSlider.leftKnobCorners = 10\n        rangeSlider.leftKnobHeight = 20\n        rangeSlider.leftKnobWidth = 20\n        rangeSlider.rightKnobColor = UIColor.systemBlue\n        rangeSlider.rightKnobCorners = 10\n        rangeSlider.rightKnobHeight = 20\n        rangeSlider.rightKnobWidth = 20\n        rangeSlider.showKnobsLabels = true\n        return rangeSlider\n    }()\n\n    private var isDragging: Bool = false\n    \n    init() {\n        self.slider.delegate = self\n    }\n}\n\nextension RangeUISliderObject: RangeUISliderDelegate {\n    public func rangeIsChanging(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        //\n    }\n    \n    public func rangeChangeFinished(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        //\n    }\n    \n    public func rangeChangeStarted() {\n        //\n    }\n}\n")),(0,a.kt)("p",null,"So first we create ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderObject")," class, which will hold our slider.\nThe slider property is created with some default configuration assigned to the slider.\nThis object class will also react to the events emitted by slider - we do it by extending the object with ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderDelegate")," protocol and setting slider's delegate property to this object's instance.\nFor now, slider event handlers are empty, but we will implement them in a second."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"For more about delegates and Delegate Pattern, see ",(0,a.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/using-delegates-to-customize-object-behavior"},"Apple's docs"),".")),(0,a.kt)("p",null,"Now it's the time to implement the Swift-Objective-C wrapper class - add the following code at the bottom of the file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},"@objc(RangeUISliderWrapperDelegate)\npublic protocol RangeUISliderWrapperDelegate: AnyObject {\n    func sendOnRangeSliderViewBeginDragEvent()\n    func sendOnRangeSliderViewEndDragEvent(minValue: Double, maxValue: Double)\n    func sendOnRangeSliderViewValueChangeEvent(minValue: Double, maxValue: Double)\n}\n\n@objc(RangeUISliderWrapper)\npublic class RangeUISliderWrapper: NSObject {\n    @objc public weak var delegate: RangeUISliderWrapperDelegate? = nil\n    \n    @objc public var activeColor: UIColor = UIColor.systemBlue\n    \n    @objc public var inactiveColor: UIColor = UIColor.systemGray\n    \n    @objc public var minValue: Double = 0.0\n    \n    @objc public var maxValue: Double = 1.0\n    \n    @objc public var leftKnobValue: Double = 0.0\n    \n    @objc public var rightKnobValue: Double = 1.0\n\n    @objc public var step: Int = 0\n}\n")),(0,a.kt)("p",null,"In the Swift-Objective-C wrapper class we declare  all the properties and methods that we want to expose to Objective-C code.\nAdditionally, we declare delegate protocol that will be also available to implement in Objective-C receiver."),(0,a.kt)(u.ZP,{mdxType:"ExportingObjCInfo"}),(0,a.kt)("p",null,"So now, let's try to combine them."),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderObject")," class let's declare ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderWrapperDelegate")," weak property, we will use to forward slider events to Objective-C receiver."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},"import RangeUISlider\nimport UIKit\n\nclass RangeUISliderObject {\n// highlight-start\n    public weak var delegate: RangeUISliderWrapperDelegate? = nil\n// highlight-end\n\n    // ...\n}\n")),(0,a.kt)("p",null,"Next, let's use that delegate property to properly implement ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderDelegate"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},"import RangeUISlider\nimport UIKit\n\nextension RangeUISliderObject: RangeUISliderDelegate {\n    public func rangeIsChanging(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n// highlight-start\n        self.delegate?.sendOnRangeSliderViewValueChangeEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n// highlight-end\n    }\n    \n    public func rangeChangeFinished(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n// highlight-start\n        if !isDragging {\n            return\n        }\n        self.delegate?.sendOnRangeSliderViewEndDragEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n        self.isDragging = false\n// highlight-end\n    }\n    \n    public func rangeChangeStarted() {\n// highlight-start\n        self.isDragging = true\n        self.delegate?.sendOnRangeSliderViewBeginDragEvent()\n// highlight-end\n    }\n}\n")),(0,a.kt)("p",null,"To make sure delegate methods are fired only when slider is dragged, we use ",(0,a.kt)("inlineCode",{parentName:"p"},"isDragging")," flag."),(0,a.kt)("p",null,"Now in ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderWrapper")," we have to initialize instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderObject"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},"@objc(RangeUISliderWrapper)\npublic class RangeUISliderWrapper: NSObject {\n    // ...\n\n// highlight-start    \n    private var sliderObject = RangeUISliderObject()\n    \n    @objc public var slider: UIView {\n        get {\n            return sliderObject.slider\n        }\n    }\n// highlight-end\n\n    // ...\n}\n")),(0,a.kt)("p",null,"Cool! Finally we can wrap everything by forwarding events from slider and forwarding props to slider. Let's add following lines:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},"@objc(RangeUISliderWrapper)\npublic class RangeUISliderWrapper: NSObject {\n// highlight-start\n    @objc public weak var delegate: RangeUISliderWrapperDelegate? = nil {\n        didSet {\n            sliderObject.delegate = delegate\n        }\n    }\n// highlight-end\n    \n    private var sliderObject = RangeUISliderObject()\n    \n    @objc public var slider: UIView {\n        get {\n            return sliderObject.slider\n        }\n    }\n    \n// highlight-start\n    @objc public var activeColor: UIColor = UIColor.systemBlue {\n        didSet {\n            sliderObject.slider.rangeSelectedColor = activeColor\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var inactiveColor: UIColor = UIColor.systemGray {\n        didSet {\n            sliderObject.slider.rangeNotSelectedColor = inactiveColor\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var minValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.scaleMinValue = minValue\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var maxValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.scaleMaxValue = maxValue\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var leftKnobValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.changeLeftKnob(value: leftKnobValue)\n            sliderObject.slider.defaultValueLeftKnob = leftKnobValue\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var rightKnobValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.changeRightKnob(value: rightKnobValue)\n            sliderObject.slider.defaultValueRightKnob = rightKnobValue\n        }\n    }\n// highlight-end\n\n// highlight-start\n    @objc public var step: Int = 0 {\n        didSet {\n            sliderObject.slider.stepIncrement = CGFloat(step)\n        }\n    }\n// highlight-end\n}\n")),(0,a.kt)("p",null,"So here we forward all the props and the delegate to the slider instance thanks to Swift's ",(0,a.kt)("inlineCode",{parentName:"p"},"didSet")," property observer.\nWe also set the frame of the slider, so that it can be resized if slider's parent changes its bounds."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Visit ",(0,a.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Property-Observers"},"Swift's docs")," to learn about ",(0,a.kt)("inlineCode",{parentName:"p"},"didSet")," property observer")),(0,a.kt)("p",null,"Awesome! We have exposed Swift-only library and we can proceed with the rest of Objective-C code."),(0,a.kt)(p.ZP,{filename:"RangeUISliderWrapper.swift",language:"swift",mdxType:"CompleteFile"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"import RangeUISlider\nimport UIKit\n\nclass RangeUISliderObject {\n    public weak var delegate: RangeUISliderWrapperDelegate? = nil\n\n    public var slider: RangeUISlider = {\n        let rangeSlider = RangeUISlider()\n        rangeSlider.barCorners = 5\n        rangeSlider.barHeight = 10\n        rangeSlider.leftKnobColor = UIColor.systemBlue\n        rangeSlider.leftKnobCorners = 10\n        rangeSlider.leftKnobHeight = 20\n        rangeSlider.leftKnobWidth = 20\n        rangeSlider.rightKnobColor = UIColor.systemBlue\n        rangeSlider.rightKnobCorners = 10\n        rangeSlider.rightKnobHeight = 20\n        rangeSlider.rightKnobWidth = 20\n        rangeSlider.showKnobsLabels = true\n        return rangeSlider\n    }()\n\n    private var isDragging: Bool = false\n    \n    init() {\n        self.slider.delegate = self\n    }\n}\n\nextension RangeUISliderObject: RangeUISliderDelegate {\n    public func rangeIsChanging(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        self.delegate?.sendOnRangeSliderViewValueChangeEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n    }\n    \n    public func rangeChangeFinished(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        if !isDragging {\n            return\n        }\n        self.delegate?.sendOnRangeSliderViewEndDragEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n        self.isDragging = false\n    }\n    \n    public func rangeChangeStarted() {\n        self.isDragging = true\n        self.delegate?.sendOnRangeSliderViewBeginDragEvent()\n    }\n}\n\n@objc(RangeUISliderWrapperDelegate)\npublic protocol RangeUISliderWrapperDelegate: AnyObject {\n    func sendOnRangeSliderViewBeginDragEvent()\n    func sendOnRangeSliderViewEndDragEvent(minValue: Double, maxValue: Double)\n    func sendOnRangeSliderViewValueChangeEvent(minValue: Double, maxValue: Double)\n}\n\n@objc(RangeUISliderWrapper)\npublic class RangeUISliderWrapper: NSObject {\n    @objc public weak var delegate: RangeUISliderWrapperDelegate? = nil {\n        didSet {\n            sliderObject.delegate = delegate\n        }\n    }\n    \n    private var sliderObject = RangeUISliderObject()\n    \n    @objc public var slider: UIView {\n        get {\n            return sliderObject.slider\n        }\n    }\n    \n    @objc public var activeColor: UIColor = UIColor.systemBlue {\n        didSet {\n            sliderObject.slider.rangeSelectedColor = activeColor\n        }\n    }\n    \n    @objc public var inactiveColor: UIColor = UIColor.systemGray {\n        didSet {\n            sliderObject.slider.rangeNotSelectedColor = inactiveColor\n        }\n    }\n    \n    @objc public var minValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.scaleMinValue = minValue\n        }\n    }\n    \n    @objc public var maxValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.scaleMaxValue = maxValue\n        }\n    }\n    \n    @objc public var leftKnobValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.changeLeftKnob(value: leftKnobValue)\n            sliderObject.slider.defaultValueLeftKnob = leftKnobValue\n        }\n    }\n    \n    @objc public var rightKnobValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.changeRightKnob(value: rightKnobValue)\n            sliderObject.slider.defaultValueRightKnob = rightKnobValue\n        }\n    }\n\n    @objc public var step: Int = 0 {\n        didSet {\n            sliderObject.slider.stepIncrement = CGFloat(step)\n        }\n    }\n}\n"))))}h.isMDXComponent=!0;const b={toc:[{value:"<code>RangeSliderView.h</code>",id:"rangesliderviewh",level:4},{value:"<code>RangeSliderView.mm</code>",id:"rangesliderviewmm",level:4}]},S="wrapper";function R(e){let{components:n,...i}=e;return(0,a.kt)(S,(0,t.Z)({},b,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"rangesliderviewh"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderView.h")),(0,a.kt)("p",null,"Now, let's work on the view that will hold our slider:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderView.h"',title:'"ios/RangeSliderView.h"'},'#import <UIKit/UIKit.h>\n\n/**\n * When using Swift classes in ObjC header, the class must have its\n * "forward declaration"\n * \n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations\n */\n@class RangeUISliderWrapper;\n@protocol RangeUISliderWrapperDelegate;\n\n@protocol RangeSliderViewDelegate\n\n- (void)sendOnRangeSliderViewBeginDragEvent;\n- (void)sendOnRangeSliderViewEndDragEventWithMinValue:(double)minValue\n                                                    maxValue:(double)maxValue;\n- (void)sendOnRangeSliderViewValueChangeEventWithMinValue:(double)minValue\n                                                        maxValue:(double)maxValue;\n\n@end\n\n@interface RangeSliderView : UIView\n\n@property (nonatomic, weak) id <RangeSliderViewDelegate> _Nullable delegate;\n\n@property (nonatomic, strong) UIColor * _Nonnull activeColor;\n@property (nonatomic, strong) UIColor * _Nonnull inactiveColor;\n@property (nonatomic) double minValue;\n@property (nonatomic) double maxValue;\n@property (nonatomic) double leftKnobValue;\n@property (nonatomic) double rightKnobValue;\n@property (nonatomic) NSInteger step;\n@property (nonatomic, copy) void (^ _Nullable onRangeSliderViewBeginDrag)(NSDictionary * _Nullable);\n@property (nonatomic, copy) void (^ _Nullable onRangeSliderViewEndDrag)(NSDictionary * _Nullable);\n@property (nonatomic, copy) void (^ _Nullable onRangeSliderViewValueChange)(NSDictionary * _Nullable);\n\n@end\n')),(0,a.kt)("p",null,"We declare our custom view that extends ",(0,a.kt)("inlineCode",{parentName:"p"},"UIView"),' and have some properties.\nThe view will also have weak delegate property - the delegate protocol is declared above the view.\nAdditionally, we do "forward declaration" for Swift elements we created before (check out Apple\'s Swift-ObjC interop ',(0,a.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations"},"dedicated docs section"),")."),(0,a.kt)("h4",{id:"rangesliderviewmm"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderView.mm")),(0,a.kt)("p",null,"With the header file ready, let's go to implementation file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderView.mm"',title:'"ios/RangeSliderView.mm"'},'#import "RangeSliderView.h"\n\n#import "RangeSliderPackage-Swift.h"\n\n@implementation RangeSliderView {\n    RangeUISliderWrapper *swiftWrapper;\n}\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        swiftWrapper = [RangeUISliderWrapper new];\n        [self addSubview:swiftWrapper.slider];\n\n        swiftWrapper.slider.translatesAutoresizingMaskIntoConstraints = NO;\n        [NSLayoutConstraint activateConstraints:@[\n            [swiftWrapper.slider.topAnchor constraintEqualToAnchor:self.topAnchor],\n            [swiftWrapper.slider.leadingAnchor constraintEqualToAnchor:self.leadingAnchor],\n            [swiftWrapper.slider.trailingAnchor constraintEqualToAnchor:self.trailingAnchor],\n            [swiftWrapper.slider.bottomAnchor constraintEqualToAnchor:self.bottomAnchor]\n        ]];\n    }\n    return self;\n}\n\n- (void)setDelegate:(id<RangeSliderViewDelegate>)delegate\n{\n    _delegate = delegate;\n    swiftWrapper.delegate = (id<RangeUISliderWrapperDelegate>) delegate;\n}\n\n- (void)setActiveColor:(UIColor *)activeColor\n{\n    _activeColor = activeColor;\n    [swiftWrapper setActiveColor:activeColor];\n}\n\n- (void)setInactiveColor:(UIColor *)inactiveColor\n{\n    _inactiveColor = inactiveColor;\n    [swiftWrapper setInactiveColor:inactiveColor];\n}\n\n- (void)setMinValue:(double)minValue\n{\n    _minValue = minValue;\n    [swiftWrapper setMinValue:minValue];\n}\n\n- (void)setMaxValue:(double)maxValue\n{\n    _maxValue = maxValue;\n    [swiftWrapper setMaxValue:maxValue];\n}\n\n- (void)setLeftKnobValue:(double)leftKnobValue\n{\n    _leftKnobValue = leftKnobValue;\n    [swiftWrapper setLeftKnobValue:leftKnobValue];\n}\n\n- (void)setRightKnobValue:(double)rightKnobValue\n{\n    _rightKnobValue = rightKnobValue;\n    [swiftWrapper setRightKnobValue:rightKnobValue];\n}\n\n- (void)setStep:(NSInteger)step\n{\n    _step = step;\n    [swiftWrapper setStep:step];\n}\n\n@end\n')),(0,a.kt)("p",null,"It may be a lot of code, but most of it is just about forwarding the properties to the swift wrapper class.\nThe swift wrapper is created in the view's ",(0,a.kt)("inlineCode",{parentName:"p"},"- initWithFrame:")," initializer, where we also add the slider as a subview.\nThe slider subview needs to match its parent size, we do it by constraining its anchors to parent anchors.\nFor more on layout constraints, visit ",(0,a.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/nslayoutanchor?language=objc"},"Auto Layout anchors section")," in Apple's docs."),(0,a.kt)("p",null,"Good, now let's use this view inside view manager and Fabric component view."))}R.isMDXComponent=!0;const v={toc:[{value:"<code>RangeSliderViewManager.h</code>",id:"rangesliderviewmanagerh",level:4},{value:"<code>RangeSliderViewManager.mm</code>",id:"rangesliderviewmanagermm",level:4}]},f="wrapper";function C(e){let{components:n,...i}=e;return(0,a.kt)(f,(0,t.Z)({},v,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"rangesliderviewmanagerh"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewManager.h")),(0,a.kt)("p",null,"As usual the view manager header will be simple:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewManager.h"',title:'"ios/RangeSliderViewManager.h"'},"#import <React/RCTUIManager.h>\n#import <React/RCTViewManager.h>\n\n@interface RangeSliderViewManager : RCTViewManager\n\n@end\n")),(0,a.kt)("p",null,"We declare the view manager class that extends ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTViewManager"),".\nOne thing you may have noticed is ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTUIManager")," import - we will use it to implement native commands for the old architecture view."),(0,a.kt)("h4",{id:"rangesliderviewmanagermm"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewManager.mm")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewManager.mm"',title:'"ios/RangeSliderViewManager.mm"'},'#import "RangeSliderViewManager.h"\n\n#import "RangeSliderView.h"\n\n#if RCT_NEW_ARCH_ENABLED\n#else\n@interface RangeSliderViewManager () <RangeSliderViewDelegate>\n@end\n#endif\n\n@implementation RangeSliderViewManager {\n    RangeSliderView *sliderView;\n}\n\nRCT_EXPORT_MODULE(RangeSliderView)\n\nRCT_EXPORT_VIEW_PROPERTY(activeColor, UIColor)\nRCT_EXPORT_VIEW_PROPERTY(inactiveColor, UIColor)\nRCT_EXPORT_VIEW_PROPERTY(leftKnobValue, double)\nRCT_EXPORT_VIEW_PROPERTY(minValue, double)\nRCT_EXPORT_VIEW_PROPERTY(maxValue, double)\nRCT_EXPORT_VIEW_PROPERTY(rightKnobValue, double)\nRCT_EXPORT_VIEW_PROPERTY(step, NSInteger)\nRCT_EXPORT_VIEW_PROPERTY(onRangeSliderViewBeginDrag, RCTDirectEventBlock)\nRCT_EXPORT_VIEW_PROPERTY(onRangeSliderViewEndDrag, RCTDirectEventBlock)\nRCT_EXPORT_VIEW_PROPERTY(onRangeSliderViewValueChange, RCTDirectEventBlock)\n\n#if RCT_NEW_ARCH_ENABLED\n#else\nRCT_EXPORT_METHOD(setLeftKnobValueProgrammatically:(nonnull NSNumber*) reactTag value:(NSInteger) value) {\n    [self.bridge.uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {\n        UIView *view = viewRegistry[reactTag];\n        if (!view || ![view isKindOfClass:[RangeSliderView class]]) {\n            return;\n        }\n        [(RangeSliderView *)view setLeftKnobValue:value];\n    }];\n}\n\nRCT_EXPORT_METHOD(setRightKnobValueProgrammatically:(nonnull NSNumber*) reactTag value:(NSInteger) value) {\n    [self.bridge.uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {\n        UIView *view = viewRegistry[reactTag];\n        if (!view || ![view isKindOfClass:[RangeSliderView class]]) {\n            return;\n        }\n        [(RangeSliderView *) view setRightKnobValue:value];\n    }];\n}\n\n- (void)sendOnRangeSliderViewValueChangeEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (slider.onRangeSliderViewValueChange) {\n        slider.onRangeSliderViewValueChange(@{ @"leftKnobValue": @(minValue), @"rightKnobValue": @(maxValue) });\n    }\n}\n\n- (void)sendOnRangeSliderViewBeginDragEvent\n{\n    if (sliderView.onRangeSliderViewBeginDrag) {\n        sliderView.onRangeSliderViewBeginDrag(nil);\n    }\n}\n\n- (void)sendOnRangeSliderViewEndDragEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (sliderView.onRangeSliderViewEndDrag) {\n        sliderView.onRangeSliderViewEndDrag(@{ @"leftKnobValue": @(minValue), @"rightKnobValue": @(maxValue) });\n    }\n}\n\n- (UIView *)view\n{\n    RangeSliderView *view = [RangeSliderView new];\n    view.delegate = self;\n    sliderView = view;\n    return view;\n}\n#endif\n\n@end\n')),(0,a.kt)("p",null,"And as for every view manager class, we start with ",(0,a.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro and we declare exported properties with ",(0,a.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_VIEW_PROPERTY")," macro."),(0,a.kt)("p",null,"For the old architecture mode, we have to do 2 additional things:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"declaring native commands (using ",(0,a.kt)("inlineCode",{parentName:"li"},"RCT_EXPORT_METHOD")," macro and ",(0,a.kt)("inlineCode",{parentName:"li"},"RCTUIManager")," class)"),(0,a.kt)("li",{parentName:"ul"},"handling events emitting (with ",(0,a.kt)("inlineCode",{parentName:"li"},"RCTDirectEventBlock")," props and ",(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderViewDelegate")," methods)")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"view")," getter is also declared for the old arch - for new arch we are just using Fabric component view."))}C.isMDXComponent=!0;const k={toc:[]},P="wrapper";function E(e){let{components:n,...i}=e;return(0,a.kt)(P,(0,t.Z)({},k,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(s,{mdxType:"IosAddLibraryInPodspec"}),(0,a.kt)(h,{mdxType:"IosObjCExposingSwiftOnlyLib"}),(0,a.kt)(R,{mdxType:"IosObjCView"}),(0,a.kt)(C,{mdxType:"IosObjCViewManager"}),(0,a.kt)(m,{mdxType:"IosObjCComponentView"}))}E.isMDXComponent=!0;const N={toc:[{value:"<code>RangeSliderViewComponentView.h</code>",id:"rangesliderviewcomponentviewh",level:4},{value:"<code>RangeSliderViewComponentView.mm</code>",id:"rangesliderviewcomponentviewmm",level:4}]},y="wrapper";function I(e){let{components:n,...i}=e;return(0,a.kt)(y,(0,t.Z)({},N,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"rangesliderviewcomponentviewh"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewComponentView.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.h"',title:'"ios/RangeSliderViewComponentView.h"'},"#if RCT_NEW_ARCH_ENABLED\n#import <React/RCTViewComponentView.h>\n\n@interface RangeSliderViewComponentView : RCTViewComponentView\n\n@end\n\n#endif\n")),(0,a.kt)("p",null,"Nothing fancy here, Fabric component view extending base ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTViewComponentView")," class."),(0,a.kt)("h4",{id:"rangesliderviewcomponentviewmm"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewComponentView.mm")),(0,a.kt)("p",null,"The implementation for the Fabric component will be quite large, so let's try to break it into parts."),(0,a.kt)("p",null,"The first part - boilerplate:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.mm"',title:'"ios/RangeSliderViewComponentView.mm"'},'#if RCT_NEW_ARCH_ENABLED\n#import "RangeSliderViewComponentView.h"\n\n#import <React/RCTConversions.h>\n\n#import <react/renderer/components/RangeSliderPackage/ComponentDescriptors.h>\n#import <react/renderer/components/RangeSliderPackage/EventEmitters.h>\n#import <react/renderer/components/RangeSliderPackage/Props.h>\n#import <react/renderer/components/RangeSliderPackage/RCTComponentViewHelpers.h>\n\n#import "RCTFabricComponentsPlugins.h"\n\nusing namespace facebook::react;\n\n@interface RangeSliderViewComponentView () <RCTRangeSliderViewViewProtocol>\n@end\n\n@implementation RangeSliderViewComponentView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        static const auto defaultProps = std::make_shared<const RangeSliderViewProps>();\n        _props = defaultProps;\n    }\n\n    return self;\n}\n\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n    const auto &oldViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(_props);\n    const auto &newViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(props);\n\n    [super updateProps:props oldProps:oldProps];\n}\n\n- (void)mountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)unmountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args\n{\n    RCTRangeSliderViewHandleCommand(self, commandName, args);\n}\n\n- (void)setLeftKnobValueProgrammatically:(double)value\n{\n    //\n}\n\n- (void)setRightKnobValueProgrammatically:(double)value\n{\n    //\n}\n\n+ (ComponentDescriptorProvider)componentDescriptorProvider\n{\n    return concreteComponentDescriptorProvider<RangeSliderViewComponentDescriptor>();\n}\n\n@end\n\nClass<RCTComponentViewProtocol> RangeSliderViewCls(void)\n{\n    return RangeSliderViewComponentView.class;\n}\n#endif\n')),(0,a.kt)("p",null,"Component begins with some new arch imports and conversion helpers."),(0,a.kt)("p",null,"We make the component extending code-generated protocol - this protocol has all the native commands methods that we declared in JS spec."),(0,a.kt)("p",null,"Next we implement all required methods and we create ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeSliderViewCls")," function."),(0,a.kt)("p",null,"If you take a closer look, we override to methods related to the child components (",(0,a.kt)("inlineCode",{parentName:"p"},"- mountChildComponentView:index:")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"- unmountChildComponentView:index:"),").\nThose methods can be used to control how the child views should be added/removed in the Fabric component.\nIn our case, we prevent adding/removal to be sure that our slider view does not have any child views."),(0,a.kt)("p",null,"Another interesting thing takes place in ",(0,a.kt)("inlineCode",{parentName:"p"},"- handleCommand:args:")," method - it invokes ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTRangeSliderViewHandleCommand")," function.\nThat function is code-generated as well as ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTRangeSliderViewViewProtocol")," protocol and is used to forward native commands calls, to dedicated methods (in our case: ",(0,a.kt)("inlineCode",{parentName:"p"},"- setLeftKnobValueProgrammatically")," & ",(0,a.kt)("inlineCode",{parentName:"p"},"- setRightKnobValueProgrammatically"),")."),(0,a.kt)("p",null,"OK - second part, let's start filling the boilerplate with our slider view:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.mm"',title:'"ios/RangeSliderViewComponentView.mm"'},'// ...\n\n// highlight-start\n#import "RangeSliderPackage-Swift.h"\n// highlight-end\n\nusing namespace facebook::react;\n\n@interface RangeSliderViewComponentView () <RCTRangeSliderViewViewProtocol>\n@end\n\n// highlight-start\n@interface RangeSliderViewComponentView () <RangeSliderViewDelegate>\n@end\n// highlight-end\n\n@implementation RangeSliderViewComponentView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        static const auto defaultProps = std::make_shared<const RangeSliderViewProps>();\n        _props = defaultProps;\n\n// highlight-start\n        RangeSliderView *view = [RangeSliderView new];\n        view.delegate = self;\n\n        self.contentView = (UIView *)view;\n// highlight-end\n    }\n\n    return self;\n}\n\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n    const auto &oldViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(_props);\n    const auto &newViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(props);\n\n// highlight-start\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n\n    if (oldViewProps.activeColor != newViewProps.activeColor) {\n        [view setActiveColor:RCTUIColorFromSharedColor(newViewProps.activeColor)];\n    }\n    \n    if (oldViewProps.inactiveColor != newViewProps.inactiveColor) {\n        [view setInactiveColor:RCTUIColorFromSharedColor(newViewProps.inactiveColor)];\n    }\n\n    if (oldViewProps.step != newViewProps.step) {\n        [view setStep:newViewProps.step];\n    }\n    \n    if (oldViewProps.minValue != newViewProps.minValue) {\n        [view setMinValue:newViewProps.minValue];\n    }\n    \n    if (oldViewProps.maxValue != newViewProps.maxValue) {\n        [view setMaxValue:newViewProps.maxValue];\n    }\n    \n    if (oldViewProps.leftKnobValue != newViewProps.leftKnobValue) {\n        [view setLeftKnobValue:newViewProps.leftKnobValue];\n    }\n    \n    if (oldViewProps.rightKnobValue != newViewProps.rightKnobValue) {\n        [view setRightKnobValue:newViewProps.rightKnobValue];\n    }\n// highlight-end\n\n    [super updateProps:props oldProps:oldProps];\n}\n\n// ...\n\n@end\n\n// ...\n')),(0,a.kt)("p",null,"What's going on here?"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderView")," is imported via ",(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderPackage-Swift.h")," import"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderViewDelegate")," is implemented by the Fabric component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderView")," is initialized and set as a ",(0,a.kt)("inlineCode",{parentName:"li"},"contentView"),", its delegate is set to this Fabric component's instance"),(0,a.kt)("li",{parentName:"ul"},"all props are handled in ",(0,a.kt)("inlineCode",{parentName:"li"},"- updateProps:oldProps:"))),(0,a.kt)("p",null,"But that's still only half of the things - XCode is probably warning you that ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeSliderViewDelegate")," is not implemented - let's fix it!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewComponentView.mm"',title:'"ios/RangeSliderViewComponentView.mm"'},"// ...\n\n@implementation RangeSliderViewComponentView\n\n// ...\n\n// highlight-start\n- (void)sendOnRangeSliderViewValueChangeEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewValueChange(\n                RangeSliderViewEventEmitter::OnRangeSliderViewValueChange{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n\n- (void)sendOnRangeSliderViewBeginDragEvent\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewBeginDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewBeginDrag{});\n    }\n}\n\n- (void)sendOnRangeSliderViewEndDragEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewEndDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewEndDrag{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n// highlight-end\n\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args\n{\n    RCTRangeSliderViewHandleCommand(self, commandName, args);\n}\n\n// highlight-start\n- (void)setLeftKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setLeftKnobValue:value];\n}\n\n- (void)setRightKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setRightKnobValue:value];\n}\n// highlight-end\n\n// ...\n\n@end\n\n// ...\n")),(0,a.kt)("p",null,"So now all warnings should be cleared - delegate methods are implemented and we also handled native commands."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Event emitters in new architecture mode are done in C++ and are code-generated")),(0,a.kt)(p.ZP,{filename:"RangeSliderViewComponentView.mm",language:"objc",mdxType:"CompleteFile"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'#if RCT_NEW_ARCH_ENABLED\n#import "RangeSliderViewComponentView.h"\n\n#import <React/RCTConversions.h>\n\n#import <react/renderer/components/RangeSliderPackage/ComponentDescriptors.h>\n#import <react/renderer/components/RangeSliderPackage/EventEmitters.h>\n#import <react/renderer/components/RangeSliderPackage/Props.h>\n#import <react/renderer/components/RangeSliderPackage/RCTComponentViewHelpers.h>\n\n#import "RCTFabricComponentsPlugins.h"\n\n#import "RangeSliderPackage-Swift.h"\n\nusing namespace facebook::react;\n\n@interface RangeSliderViewComponentView () <RCTRangeSliderViewViewProtocol>\n@end\n\n@interface RangeSliderViewComponentView () <RangeSliderViewDelegate>\n@end\n\n@implementation RangeSliderViewComponentView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        static const auto defaultProps = std::make_shared<const RangeSliderViewProps>();\n        _props = defaultProps;\n\n        RangeSliderView *view = [RangeSliderView new];\n        view.delegate = self;\n\n        self.contentView = (UIView *)view;\n    }\n\n    return self;\n}\n\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n    const auto &oldViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(_props);\n    const auto &newViewProps = *std::static_pointer_cast<const RangeSliderViewProps>(props);\n\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n\n    if (oldViewProps.activeColor != newViewProps.activeColor) {\n        [view setActiveColor:RCTUIColorFromSharedColor(newViewProps.activeColor)];\n    }\n    \n    if (oldViewProps.inactiveColor != newViewProps.inactiveColor) {\n        [view setInactiveColor:RCTUIColorFromSharedColor(newViewProps.inactiveColor)];\n    }\n\n    if (oldViewProps.step != newViewProps.step) {\n        [view setStep:newViewProps.step];\n    }\n    \n    if (oldViewProps.minValue != newViewProps.minValue) {\n        [view setMinValue:newViewProps.minValue];\n    }\n    \n    if (oldViewProps.maxValue != newViewProps.maxValue) {\n        [view setMaxValue:newViewProps.maxValue];\n    }\n    \n    if (oldViewProps.leftKnobValue != newViewProps.leftKnobValue) {\n        [view setLeftKnobValue:newViewProps.leftKnobValue];\n    }\n    \n    if (oldViewProps.rightKnobValue != newViewProps.rightKnobValue) {\n        [view setRightKnobValue:newViewProps.rightKnobValue];\n    }\n\n    [super updateProps:props oldProps:oldProps];\n}\n\n- (void)mountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)unmountChildComponentView:(UIView<RCTComponentViewProtocol> *)childComponentView index:(NSInteger)index\n{\n    // That component does not accept child views\n}\n\n- (void)sendOnRangeSliderViewValueChangeEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewValueChange(\n                RangeSliderViewEventEmitter::OnRangeSliderViewValueChange{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n\n- (void)sendOnRangeSliderViewBeginDragEvent\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewBeginDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewBeginDrag{});\n    }\n}\n\n- (void)sendOnRangeSliderViewEndDragEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (_eventEmitter != nil) {\n        std::dynamic_pointer_cast<const RangeSliderViewEventEmitter>(_eventEmitter)\n            ->onRangeSliderViewEndDrag(\n                RangeSliderViewEventEmitter::OnRangeSliderViewEndDrag{\n                    .leftKnobValue = minValue,\n                    .rightKnobValue = maxValue\n                });\n    }\n}\n\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args\n{\n    RCTRangeSliderViewHandleCommand(self, commandName, args);\n}\n\n- (void)setLeftKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setLeftKnobValue:value];\n}\n\n- (void)setRightKnobValueProgrammatically:(double)value\n{\n    RangeSliderView *view = (RangeSliderView *)self.contentView;\n    [view setRightKnobValue:value];\n}\n\n+ (ComponentDescriptorProvider)componentDescriptorProvider\n{\n    return concreteComponentDescriptorProvider<RangeSliderViewComponentDescriptor>();\n}\n\n@end\n\nClass<RCTComponentViewProtocol> RangeSliderViewCls(void)\n{\n    return RangeSliderViewComponentView.class;\n}\n#endif\n'))))}I.isMDXComponent=!0;const T={toc:[{value:"<code>RangeSliderView.swift</code>",id:"rangesliderviewswift",level:4}]},_="wrapper";function D(e){let{components:n,...i}=e;return(0,a.kt)(_,(0,t.Z)({},T,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"rangesliderviewswift"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderView.swift")),(0,a.kt)("p",null,"We will start by defining the boilerplate for our custom view:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeSliderView.swift"',title:'"ios/RangeSliderView.swift"'},"import UIKit\n\n@objc(RangeSliderViewDelegate)\npublic protocol RangeSliderViewDelegate {\n    func sendOnRangeSliderViewBeginDragEvent()\n    func sendOnRangeSliderViewEndDragEvent(minValue: Double, maxValue: Double)\n    func sendOnRangeSliderViewValueChangeEvent(minValue: Double, maxValue: Double)\n}\n\n@objc(RangeSliderView)\npublic class RangeSliderView: UIView {\n    @objc public weak var delegate: RangeSliderViewDelegate? = nil\n\n    @objc public var onRangeSliderViewBeginDrag: ((NSDictionary?) -> Void)? = nil\n    @objc public var onRangeSliderViewEndDrag: ((NSDictionary?) -> Void)? = nil\n    @objc public var onRangeSliderViewValueChange: ((NSDictionary?) -> Void)? = nil\n    \n    @objc public var activeColor: UIColor = UIColor.systemBlue\n    \n    @objc public var inactiveColor: UIColor = UIColor.systemGray\n    \n    @objc public var minValue: Double = 0.0\n    \n    @objc public var maxValue: Double = 1.0\n    \n    @objc public var leftKnobValue: Double = 0.0\n    \n    @objc public var rightKnobValue: Double = 1.0\n\n    @objc public var step: Int = 0\n}\n")),(0,a.kt)("p",null,"We'll export 2 things to the Objective-C world - our view and its delegate protocol.\nFor now all view's properties have only some default values, but we will add some code later to forward them to the slider."),(0,a.kt)(u.ZP,{mdxType:"ExportingObjCInfo"}),(0,a.kt)("p",null,"Next step is to create the slider - will wrap the slider in the object class that will keep the slider and react to the slider's events."),(0,a.kt)("p",null,"Add the following snippet at the top of the file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeSliderView.swift"',title:'"ios/RangeSliderView.swift"'},"import RangeUISlider\nimport UIKit\n\nclass RangeUISliderObject {\n    public weak var delegate: RangeSliderViewDelegate? = nil\n    \n    public var slider: RangeUISlider = {\n        let rangeSlider = RangeUISlider()\n        rangeSlider.barCorners = 5\n        rangeSlider.barHeight = 10\n        rangeSlider.leftKnobColor = UIColor.systemBlue\n        rangeSlider.leftKnobCorners = 10\n        rangeSlider.leftKnobHeight = 20\n        rangeSlider.leftKnobWidth = 20\n        rangeSlider.rightKnobColor = UIColor.systemBlue\n        rangeSlider.rightKnobCorners = 10\n        rangeSlider.rightKnobHeight = 20\n        rangeSlider.rightKnobWidth = 20\n        rangeSlider.showKnobsLabels = true\n        return rangeSlider\n    }()\n\n    private var isDragging: Bool = false\n    \n    init() {\n        self.slider.delegate = self\n    }\n}\n\nextension RangeUISliderObject: RangeUISliderDelegate {\n    public func rangeIsChanging(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        self.delegate?.sendOnRangeSliderViewValueChangeEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n    }\n    \n    public func rangeChangeFinished(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        if !isDragging {\n            return\n        }\n        self.delegate?.sendOnRangeSliderViewEndDragEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n        self.isDragging = false\n    }\n    \n    public func rangeChangeStarted() {\n        self.isDragging = true\n        self.delegate?.sendOnRangeSliderViewBeginDragEvent()\n    }\n}\n")),(0,a.kt)("p",null,"So first we create ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderObject")," class, which will hold our slider.\nThe slider property is created with some default configuration assigned to the slider.\nThis object class will also react to the events emitted by slider - we do it by extending the object with ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeUISliderDelegate")," protocol and setting slider's delegate property to this object's instance.\nAnd to make sure delegate methods are fired only when slider is dragged, we use ",(0,a.kt)("inlineCode",{parentName:"p"},"isDragging")," flag."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"For more about delegates and Delegate Pattern, see ",(0,a.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/using-delegates-to-customize-object-behavior"},"Apple's docs"),".")),(0,a.kt)("p",null,"So now, let's try to combine them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},'// ...\n\n@objc(RangeSliderView)\npublic class RangeSliderView: UIView  {\n    // ...\n    \n// highlight-start\n    private var sliderObject = RangeUISliderObject()\n\n    public override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.sliderObject.delegate = self.delegate\n        self.addSubview(self.sliderObject.slider)\n\n        self.sliderObject.slider.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            self.sliderObject.slider.topAnchor.constraint(equalTo: self.topAnchor),\n            self.sliderObject.slider.leadingAnchor.constraint(equalTo: self.leadingAnchor),\n            self.sliderObject.slider.trailingAnchor.constraint(equalTo: self.trailingAnchor),\n            self.sliderObject.slider.bottomAnchor.constraint(equalTo: self.bottomAnchor)\n        ])\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError("init(coder:) has not been implemented")\n    }\n// highlight-end\n\n    // ...\n}\n')),(0,a.kt)("p",null,"Here, we're initializing slider object and the slider is added as a subview."),(0,a.kt)("p",null,"The slider object is created in the view's ",(0,a.kt)("inlineCode",{parentName:"p"},"init(frame:)")," initializer, where we also add the slider as a subview.\nThe slider subview needs to match its parent size, we do it by constraining its anchors to parent anchors.\nFor more on layout constraints, visit ",(0,a.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/nslayoutanchor"},"Auto Layout anchors section")," in Apple's docs."),(0,a.kt)("p",null,"The only thing left is to forward all properties to the slider:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/RangeUISliderWrapper.swift"',title:'"ios/RangeUISliderWrapper.swift"'},'// ...\n\n@objc(RangeSliderView)\npublic class RangeSliderView: UIView  {\n// highlight-start\n    @objc public weak var delegate: RangeSliderViewDelegate? = nil {\n        didSet {\n            sliderObject.delegate = delegate\n        }\n    }\n// highlight-end\n\n    @objc public var onRangeSliderViewBeginDrag: ((NSDictionary?) -> Void)? = nil\n    @objc public var onRangeSliderViewEndDrag: ((NSDictionary?) -> Void)? = nil\n    @objc public var onRangeSliderViewValueChange: ((NSDictionary?) -> Void)? = nil\n    \n    private var sliderObject = RangeUISliderObject()\n\n    public override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.sliderObject.delegate = self.delegate\n        self.addSubview(self.sliderObject.slider)\n\n        self.sliderObject.slider.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            self.sliderObject.slider.topAnchor.constraint(equalTo: self.topAnchor),\n            self.sliderObject.slider.leadingAnchor.constraint(equalTo: self.leadingAnchor),\n            self.sliderObject.slider.trailingAnchor.constraint(equalTo: self.trailingAnchor),\n            self.sliderObject.slider.bottomAnchor.constraint(equalTo: self.bottomAnchor)\n        ])\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError("init(coder:) has not been implemented")\n    }\n\n// highlight-start\n    @objc public var activeColor: UIColor = UIColor.systemBlue {\n        didSet {\n            sliderObject.slider.rangeSelectedColor = activeColor\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var inactiveColor: UIColor = UIColor.systemGray {\n        didSet {\n            sliderObject.slider.rangeNotSelectedColor = inactiveColor\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var minValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.scaleMinValue = minValue\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var maxValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.scaleMaxValue = maxValue\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var leftKnobValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.changeLeftKnob(value: leftKnobValue)\n            sliderObject.slider.defaultValueLeftKnob = leftKnobValue\n        }\n    }\n// highlight-end\n    \n// highlight-start\n    @objc public var rightKnobValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.changeRightKnob(value: rightKnobValue)\n            sliderObject.slider.defaultValueRightKnob = rightKnobValue\n        }\n    }\n// highlight-end\n\n// highlight-start\n    @objc public var step: Int = 0 {\n        didSet {\n            sliderObject.slider.stepIncrement = CGFloat(step)\n        }\n    }\n// highlight-end\n}\n')),(0,a.kt)("p",null,"So here we forward all the props and the delegate to the slider instance thanks to Swift's ",(0,a.kt)("inlineCode",{parentName:"p"},"didSet")," property observer.\nWe also set the frame of the slider, so that it can be resized if slider's parent changes its bounds."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Visit ",(0,a.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Property-Observers"},"Swift's docs")," to learn about ",(0,a.kt)("inlineCode",{parentName:"p"},"didSet")," property observer")),(0,a.kt)("p",null,"Good, now let's use this view inside view manager and Fabric component view."),(0,a.kt)(p.ZP,{filename:"RangeSliderView.swift",language:"swift",mdxType:"CompleteFile"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'import RangeUISlider\nimport UIKit\n\nclass RangeUISliderObject {\n    public weak var delegate: RangeSliderViewDelegate? = nil\n    \n    public var slider: RangeUISlider = {\n        let rangeSlider = RangeUISlider()\n        rangeSlider.barCorners = 5\n        rangeSlider.barHeight = 10\n        rangeSlider.leftKnobColor = UIColor.systemBlue\n        rangeSlider.leftKnobCorners = 10\n        rangeSlider.leftKnobHeight = 20\n        rangeSlider.leftKnobWidth = 20\n        rangeSlider.rightKnobColor = UIColor.systemBlue\n        rangeSlider.rightKnobCorners = 10\n        rangeSlider.rightKnobHeight = 20\n        rangeSlider.rightKnobWidth = 20\n        rangeSlider.showKnobsLabels = true\n        return rangeSlider\n    }()\n\n    private var isDragging: Bool = false\n    \n    init() {\n        self.slider.delegate = self\n    }\n}\n\nextension RangeUISliderObject: RangeUISliderDelegate {\n    public func rangeIsChanging(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        self.delegate?.sendOnRangeSliderViewValueChangeEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n    }\n    \n    public func rangeChangeFinished(minValueSelected: CGFloat, maxValueSelected: CGFloat, slider: RangeUISlider) {\n        if !isDragging {\n            return\n        }\n        self.delegate?.sendOnRangeSliderViewEndDragEvent(minValue: minValueSelected, maxValue: maxValueSelected)\n        self.isDragging = false\n    }\n    \n    public func rangeChangeStarted() {\n        self.isDragging = true\n        self.delegate?.sendOnRangeSliderViewBeginDragEvent()\n    }\n}\n\n@objc(RangeSliderViewDelegate)\npublic protocol RangeSliderViewDelegate {\n    func sendOnRangeSliderViewBeginDragEvent()\n    func sendOnRangeSliderViewEndDragEvent(minValue: Double, maxValue: Double)\n    func sendOnRangeSliderViewValueChangeEvent(minValue: Double, maxValue: Double)\n}\n\n@objc(RangeSliderView)\npublic class RangeSliderView: UIView {\n    @objc public weak var delegate: RangeSliderViewDelegate? = nil {\n        didSet {\n            sliderObject.delegate = delegate\n        }\n    }\n\n    @objc public var onRangeSliderViewBeginDrag: ((NSDictionary?) -> Void)? = nil\n    @objc public var onRangeSliderViewEndDrag: ((NSDictionary?) -> Void)? = nil\n    @objc public var onRangeSliderViewValueChange: ((NSDictionary?) -> Void)? = nil\n\n    private var sliderObject = RangeUISliderObject()\n\n    public override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.sliderObject.delegate = self.delegate\n        self.addSubview(self.sliderObject.slider)\n\n        self.sliderObject.slider.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            self.sliderObject.slider.topAnchor.constraint(equalTo: self.topAnchor),\n            self.sliderObject.slider.leadingAnchor.constraint(equalTo: self.leadingAnchor),\n            self.sliderObject.slider.trailingAnchor.constraint(equalTo: self.trailingAnchor),\n            self.sliderObject.slider.bottomAnchor.constraint(equalTo: self.bottomAnchor)\n        ])\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError("init(coder:) has not been implemented")\n    }\n    \n    @objc public var activeColor: UIColor = UIColor.systemBlue {\n        didSet {\n            sliderObject.slider.rangeSelectedColor = activeColor\n        }\n    }\n    \n    @objc public var inactiveColor: UIColor = UIColor.systemGray {\n        didSet {\n            sliderObject.slider.rangeNotSelectedColor = inactiveColor\n        }\n    }\n    \n    @objc public var minValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.scaleMinValue = minValue\n        }\n    }\n    \n    @objc public var maxValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.scaleMaxValue = maxValue\n        }\n    }\n    \n    @objc public var leftKnobValue: Double = 0.0 {\n        didSet {\n            sliderObject.slider.changeLeftKnob(value: leftKnobValue)\n            sliderObject.slider.defaultValueLeftKnob = leftKnobValue\n        }\n    }\n    \n    @objc public var rightKnobValue: Double = 1.0 {\n        didSet {\n            sliderObject.slider.changeRightKnob(value: rightKnobValue)\n            sliderObject.slider.defaultValueRightKnob = rightKnobValue\n        }\n    }\n\n    @objc public var step: Int = 0 {\n        didSet {\n            sliderObject.slider.stepIncrement = CGFloat(step)\n        }\n    }\n}\n'))))}D.isMDXComponent=!0;const O={toc:[{value:"<code>RangeSliderViewManager.h</code>",id:"rangesliderviewmanagerh",level:4},{value:"<code>RangeSliderViewManager.mm</code>",id:"rangesliderviewmanagermm",level:4}]},j="wrapper";function x(e){let{components:n,...i}=e;return(0,a.kt)(j,(0,t.Z)({},O,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"rangesliderviewmanagerh"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewManager.h")),(0,a.kt)("p",null,"As usual the view manager header will be simple:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewManager.h"',title:'"ios/RangeSliderViewManager.h"'},"#import <React/RCTUIManager.h>\n#import <React/RCTViewManager.h>\n\n@interface RangeSliderViewManager : RCTViewManager\n\n@end\n")),(0,a.kt)("p",null,"We declare the view manager class that extends ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTViewManager"),".\nOne thing you may have noticed is ",(0,a.kt)("inlineCode",{parentName:"p"},"RCTUIManager")," import - we will use it to implement native commands for the old architecture view."),(0,a.kt)("h4",{id:"rangesliderviewmanagermm"},(0,a.kt)("inlineCode",{parentName:"h4"},"RangeSliderViewManager.mm")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/RangeSliderViewManager.mm"',title:'"ios/RangeSliderViewManager.mm"'},'#import "RangeSliderViewManager.h"\n\n#import "RangeSliderPackage-Swift.h"\n\n#if RCT_NEW_ARCH_ENABLED\n#else\n@interface RangeSliderViewManager () <RangeSliderViewDelegate>\n@end\n#endif\n\n@implementation RangeSliderViewManager {\n    RangeSliderView *sliderView;\n}\n\nRCT_EXPORT_MODULE(RangeSliderView)\n\nRCT_EXPORT_VIEW_PROPERTY(activeColor, UIColor)\nRCT_EXPORT_VIEW_PROPERTY(inactiveColor, UIColor)\nRCT_EXPORT_VIEW_PROPERTY(leftKnobValue, double)\nRCT_EXPORT_VIEW_PROPERTY(minValue, double)\nRCT_EXPORT_VIEW_PROPERTY(maxValue, double)\nRCT_EXPORT_VIEW_PROPERTY(rightKnobValue, double)\nRCT_EXPORT_VIEW_PROPERTY(step, NSInteger)\nRCT_EXPORT_VIEW_PROPERTY(onRangeSliderViewBeginDrag, RCTDirectEventBlock)\nRCT_EXPORT_VIEW_PROPERTY(onRangeSliderViewEndDrag, RCTDirectEventBlock)\nRCT_EXPORT_VIEW_PROPERTY(onRangeSliderViewValueChange, RCTDirectEventBlock)\n\n#if RCT_NEW_ARCH_ENABLED\n#else\nRCT_EXPORT_METHOD(setLeftKnobValueProgrammatically:(nonnull NSNumber*) reactTag value:(NSInteger) value) {\n    [self.bridge.uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {\n        UIView *view = viewRegistry[reactTag];\n        if (!view || ![view isKindOfClass:[RangeSliderView class]]) {\n            return;\n        }\n        [(RangeSliderView *)view setLeftKnobValue:value];\n    }];\n}\n\nRCT_EXPORT_METHOD(setRightKnobValueProgrammatically:(nonnull NSNumber*) reactTag value:(NSInteger) value) {\n    [self.bridge.uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {\n        UIView *view = viewRegistry[reactTag];\n        if (!view || ![view isKindOfClass:[RangeSliderView class]]) {\n            return;\n        }\n        [(RangeSliderView *) view setRightKnobValue:value];\n    }];\n}\n\n- (void)sendOnRangeSliderViewValueChangeEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (sliderView.onRangeSliderViewValueChange) {\n        sliderView.onRangeSliderViewValueChange(@{ @"leftKnobValue": @(minValue), @"rightKnobValue": @(maxValue) });\n    }\n}\n\n- (void)sendOnRangeSliderViewBeginDragEvent\n{\n    if (sliderView.onRangeSliderViewBeginDrag) {\n        sliderView.onRangeSliderViewBeginDrag(nil);\n    }\n}\n\n- (void)sendOnRangeSliderViewEndDragEventWithMinValue:(double)minValue maxValue:(double)maxValue\n{\n    if (sliderView.onRangeSliderViewEndDrag) {\n        sliderView.onRangeSliderViewEndDrag(@{ @"leftKnobValue": @(minValue), @"rightKnobValue": @(maxValue) });\n    }\n}\n\n- (UIView *)view\n{\n    RangeSliderView *view = [RangeSliderView new];\n    view.delegate = self;\n    sliderView = view;\n    return view;\n}\n#endif\n\n@end\n')),(0,a.kt)("p",null,"And as for every view manager class, we start with ",(0,a.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro and we declare exported properties with ",(0,a.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_VIEW_PROPERTY")," macro."),(0,a.kt)("p",null,"For the old architecture mode, we have to do 2 additional things:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"declaring native commands (using ",(0,a.kt)("inlineCode",{parentName:"li"},"RCT_EXPORT_METHOD")," macro and ",(0,a.kt)("inlineCode",{parentName:"li"},"RCTUIManager")," class)"),(0,a.kt)("li",{parentName:"ul"},"handling events emitting (with ",(0,a.kt)("inlineCode",{parentName:"li"},"RCTDirectEventBlock")," props and ",(0,a.kt)("inlineCode",{parentName:"li"},"RangeSliderViewDelegate")," methods)")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"view")," getter is also declared for the old arch - for new arch we are just using Fabric component view."))}x.isMDXComponent=!0;const U={toc:[]},K="wrapper";function W(e){let{components:n,...i}=e;return(0,a.kt)(K,(0,t.Z)({},U,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(s,{mdxType:"IosAddLibraryInPodspec"}),(0,a.kt)(D,{mdxType:"IosSwiftView"}),(0,a.kt)(x,{mdxType:"IosSwiftViewManager"}),(0,a.kt)(I,{mdxType:"IosSwiftComponentView"}))}W.isMDXComponent=!0;const A={sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},M=void 0,L={unversionedId:"guides/range-slider-view/ios-impl",id:"guides/range-slider-view/ios-impl",title:"iOS implementation",description:"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:",source:"@site/docs/guides/range-slider-view/ios-impl.mdx",sourceDirName:"guides/range-slider-view",slug:"/guides/range-slider-view/ios-impl",permalink:"/rnbridgingtutorial/docs/guides/range-slider-view/ios-impl",draft:!1,editUrl:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/docs/docs/guides/range-slider-view/ios-impl.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},sidebar:"tutorialSidebar",previous:{title:"JS specification",permalink:"/rnbridgingtutorial/docs/guides/range-slider-view/js-spec"},next:{title:"Android implementation",permalink:"/rnbridgingtutorial/docs/guides/range-slider-view/android-impl"}},F={},B=[],X={toc:B},H="wrapper";function G(e){let{components:n,...i}=e;return(0,a.kt)(H,(0,t.Z)({},X,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"xed ios\n")),(0,a.kt)("p",null,"When workspace is opened, locate ",(0,a.kt)("inlineCode",{parentName:"p"},"Pods")," project and expand it. Search for ",(0,a.kt)("inlineCode",{parentName:"p"},"Development Pods")," and find ",(0,a.kt)("inlineCode",{parentName:"p"},"RangeSliderPackage")," inside. When it's expanded, it will show all files that we created under ",(0,a.kt)("inlineCode",{parentName:"p"},"range-slider-package/ios")," directory."),(0,a.kt)(r.Z,{groupId:"ios_lang",mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"swift",label:"ObjC++ & Swift",mdxType:"TabItem"},(0,a.kt)(W,{mdxType:"IosSwiftImpl"})),(0,a.kt)(l.Z,{value:"objc",label:"ObjC++ only",mdxType:"TabItem"},(0,a.kt)(E,{mdxType:"IosObjCImpl"}))),(0,a.kt)("p",null,"You can check training repo for Objective-C & Swift implementation ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/range-slider-package"},"here")," and Objective-C-only implementation ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/range-slider-package-classic"},"here"),"."),(0,a.kt)("p",null,"That's iOS part, now let's go to Android!"))}G.isMDXComponent=!0}}]);