"use strict";(self.webpackChunkbridging_tutorial_website=self.webpackChunkbridging_tutorial_website||[]).push([[3740],{5162:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(7294),o=t(6010);const i={tabItem:"tabItem_Ymn6"};function r(e){let{children:n,hidden:t,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i.tabItem,r),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>C});var a=t(7462),o=t(7294),i=t(6010),r=t(2466),l=t(6550),c=t(1980),d=t(7392),s=t(12);function u(e){return function(e){return o.Children.map(e,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:o}}=e;return{value:n,label:t,attributes:a,default:o}}))}function p(e){const{values:n,children:t}=e;return(0,o.useMemo)((()=>{const e=n??u(t);return function(e){const n=(0,d.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const a=(0,l.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c._X)(i),(0,o.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(a.location.search);n.set(i,e),a.replace({...a.location,search:n.toString()})}),[i,a])]}function v(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,i=p(e),[r,l]=(0,o.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[c,d]=g({queryString:t,groupId:a}),[u,v]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,i]=(0,s.Nk)(t);return[a,(0,o.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:a}),h=(()=>{const e=c??u;return m({value:e,tabValues:i})?e:null})();(0,o.useLayoutEffect)((()=>{h&&l(h)}),[h]);return{selectedValue:r,selectValue:(0,o.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),v(e)}),[d,v,i]),tabValues:i}}var h=t(2389);const k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function M(e){let{className:n,block:t,selectedValue:l,selectValue:c,tabValues:d}=e;const s=[],{blockElementScrollPositionUntilNextRender:u}=(0,r.o5)(),p=e=>{const n=e.currentTarget,t=s.indexOf(n),a=d[t].value;a!==l&&(u(n),c(a))},m=e=>{let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;n=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;n=s[t]??s[s.length-1];break}}n?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n)},d.map((e=>{let{value:n,label:t,attributes:r}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>s.push(e),onKeyDown:m,onClick:p},r,{className:(0,i.Z)("tabs__item",k.tabItem,r?.className,{"tabs__item--active":l===n})}),t??n)})))}function b(e){let{lazy:n,children:t,selectedValue:a}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function f(e){const n=v(e);return o.createElement("div",{className:(0,i.Z)("tabs-container",k.tabList)},o.createElement(M,(0,a.Z)({},e,n)),o.createElement(b,(0,a.Z)({},e,n)))}function C(e){const n=(0,h.Z)();return o.createElement(f,(0,a.Z)({key:String(n)},e))}},6105:(e,n,t)=>{t.d(n,{ZP:()=>c});var a=t(7462),o=(t(7294),t(3905)),i=t(814);const r={toc:[]},l="wrapper";function c(e){let{components:n,...t}=e;return(0,o.kt)(l,(0,a.Z)({},r,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h4",null,(0,o.kt)("code",null,t.packageClass,".","java"===t.language?"java":"kt")),(0,o.kt)("p",null,"The last thing we need to do is to export ",(0,o.kt)("code",null,t.viewManagerClass?t.viewManagerClass:t.moduleClass)," in the ",(0,o.kt)("code",null,"TurboReactPackage")," instance. Let's go to ",(0,o.kt)("code",null,t.packageClass,".","java"===t.language?"java":"kt")," and add our new module."),(0,o.kt)(i.Z,{language:t.language,title:`android/src/main/java/com/${t.namespace}/${t.packageClass}.${"java"===t.language?"java":"kt"}`,mdxType:"CodeBlock"},"java"===t.language?`package com.${t.namespace};\n\nimport androidx.annotation.Nullable;\n\nimport com.facebook.react.TurboReactPackage;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.module.annotations.ReactModule;\nimport com.facebook.react.module.model.ReactModuleInfo;\nimport com.facebook.react.module.model.ReactModuleInfoProvider;\nimport com.facebook.react.turbomodule.core.interfaces.TurboModule;\n${t.viewManagerClass?"// highlight-start\nimport com.facebook.react.uimanager.ViewManager;\n\nimport java.util.Arrays;\n// highlight-end":""}\nimport java.util.HashMap;${t.viewManagerClass?"\n// highlight-start\nimport java.util.List;\n// highlight-end":""}\nimport java.util.Map;\n\npublic class ${t.packageClass} extends TurboReactPackage {\n    /**\n     * Initialize and export modules based on the name of the required module\n     */\n    @Override\n    @Nullable\n    public NativeModule getModule(String name, ReactApplicationContext reactContext) {\n        ${t.moduleClass?`// highlight-start\n        if (name.equals(${t.moduleClass}.NAME)) {\n            return new ${t.moduleClass}(reactContext);\n        }\n        return null;\n// highlight-end`:"return null;"}\n    }\n\n    /**\n     * Declare info about exported modules\n     */\n    @Override\n    public ReactModuleInfoProvider getReactModuleInfoProvider() {\n        /**\n         * Here declare the array of exported modules\n         */\n        Class<? extends NativeModule>[] moduleList = new Class[] {${t.moduleClass?`\n// highlight-start\n            ${t.moduleClass}.class\n            // highlight-end`:""}\n        };\n        final Map<String, ReactModuleInfo> reactModuleInfoMap = new HashMap<>();\n        /**\n         * And here just iterate on that array and produce the info provider instance\n         */\n        for (Class<? extends NativeModule> moduleClass : moduleList) {\n            ReactModule reactModule = moduleClass.getAnnotation(ReactModule.class);\n\n            reactModuleInfoMap.put(\n                reactModule.name(),\n                new ReactModuleInfo(\n                    reactModule.name(),\n                    moduleClass.getName(),\n                    true,\n                    reactModule.needsEagerInit(),\n                    reactModule.hasConstants(),\n                    reactModule.isCxxModule(),\n                    TurboModule.class.isAssignableFrom(moduleClass)\n                )\n            );\n        }\n\n        return new ReactModuleInfoProvider() {\n            @Override\n            public Map<String, ReactModuleInfo> getReactModuleInfos() {\n                return reactModuleInfoMap;\n            }\n        };\n    }${t.viewManagerClass?`\n\n// highlight-start\n    @Override\n    public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {\n        /**\n        * Here declare the list of exported native components\n        */\n        return Arrays.<ViewManager>asList(new ${t.viewManagerClass}());\n    }\n    // highlight-end`:""}\n}`:`package com.${t.namespace}\n\nimport com.facebook.react.TurboReactPackage\nimport com.facebook.react.bridge.NativeModule\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.module.annotations.ReactModule\nimport com.facebook.react.module.model.ReactModuleInfo\nimport com.facebook.react.module.model.ReactModuleInfoProvider\nimport com.facebook.react.turbomodule.core.interfaces.TurboModule${t.viewManagerClass?"\n// highlight-start\nimport com.facebook.react.uimanager.ViewManager\n// highlight-end":""}\n\nclass ${t.packageClass} : TurboReactPackage() {\n    /**\n     * Initialize and export modules based on the name of the required module\n     */\n    override fun getModule(name: String, reactContext: ReactApplicationContext): NativeModule? {\n        ${t.moduleClass?`// highlight-start\n        return when (name) {\n            ${t.moduleClass}.NAME -> ${t.moduleClass}(reactContext)\n            else -> null\n        }\n        // highlight-end`:"return null"}\n    }\n\n    /**\n     * Declare info about exported modules\n     */\n    override fun getReactModuleInfoProvider(): ReactModuleInfoProvider {\n        /**\n         * Here declare the array of exported modules\n         */\n        val moduleList: Array<Class<out NativeModule?>> = arrayOf(${t.moduleClass?`\n// highlight-start\n            ${t.moduleClass}::class.java\n            // highlight-end`:""}\n        )\n        val reactModuleInfoMap: MutableMap<String, ReactModuleInfo> = HashMap()\n        /**\n         * And here just iterate on that array and produce the info provider instance\n         */\n        for (moduleClass in moduleList) {\n            val reactModule = moduleClass.getAnnotation(ReactModule::class.java) ?: continue\n            reactModuleInfoMap[reactModule.name] =\n                ReactModuleInfo(\n                    reactModule.name,\n                    moduleClass.name,\n                    true,\n                    reactModule.needsEagerInit,\n                    reactModule.hasConstants,\n                    reactModule.isCxxModule,\n                    TurboModule::class.java.isAssignableFrom(moduleClass)\n                )\n        }\n        return ReactModuleInfoProvider { reactModuleInfoMap }\n    }${t.viewManagerClass?`\n\n// highlight-start\n    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {\n        /**\n        * Here declare the list of exported native components\n        */\n        return listOf(${t.viewManagerClass}())\n    }\n    // highlight-end`:""}\n}`),(0,o.kt)("div",null,t.moduleClass?(0,o.kt)("div",null,(0,o.kt)("p",null,"To export the module, as the first step, we need to return it from ",(0,o.kt)("code",null,"getModule")," method inside ",(0,o.kt)("code",null,t.packageClass),", if it's requested (the method takes name as a parameter and makes decision which module should be served)."),(0,o.kt)("p",null,"The second step is to implement ",(0,o.kt)("code",null,"getReactModuleInfoProvider")," method, where the module is injected to the info provider instance.")):t.viewManagerClass?(0,o.kt)("p",null,"Here the most important bit is ",(0,o.kt)("code",null,"createViewManagers")," method, which returns collection of view manager classes. Because our package exports only a single view, we register one-element list, with ",(0,o.kt)("code",null,t.viewManagerClass)," class."):null))}c.isMDXComponent=!0},5259:(e,n,t)=>{t.d(n,{ZP:()=>c});var a=t(7462),o=(t(7294),t(3905)),i=t(814);const r={toc:[]},l="wrapper";function c(e){let{components:n,...t}=e;return(0,o.kt)(l,(0,a.Z)({},r,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Old architecture module"),(0,o.kt)("div",null,"The implementation of old architecture module won't be visible in Android Studio when you have new architecture enabled. To handle that, you can open ",(0,o.kt)("code",null,t.filename)," at other text editor and paste following content:",(0,o.kt)("br",null),(0,o.kt)("br",null),(0,o.kt)(i.Z,{language:t.language,mdxType:"CodeBlock"},t.children))))}c.isMDXComponent=!0},7106:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>T,contentTitle:()=>x,default:()=>D,frontMatter:()=>E,metadata:()=>I,toc:()=>R});var a=t(7462),o=(t(7294),t(3905)),i=t(4866),r=t(5162),l=t(6105),c=t(5259);const d={toc:[{value:"<code>ScreenOrientationModule.java</code>",id:"screenorientationmodulejava",level:4}]},s="wrapper";function u(e){let{components:n,...t}=e;return(0,o.kt)(s,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h4",{id:"screenorientationmodulejava"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModule.java")),(0,o.kt)("p",null,"Now, let's move to the module class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/newarch/java/com/screenorientationpackage/ScreenOrientationModule.java"',title:'"android/src/newarch/java/com/screenorientationpackage/ScreenOrientationModule.java"'},'package com.screenorientationpackage;\n\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.module.annotations.ReactModule;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Declare Java class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = ScreenOrientationModule.NAME)\npublic class ScreenOrientationModule extends NativeScreenOrientationModuleSpec {\n    public static final String PORTRAIT = "PORTRAIT";\n    public static final String LANDSCAPE = "LANDSCAPE";\n    public static final String NAME = ScreenOrientationModuleImpl.NAME;\n\n    // Use shared module implementation and forward react application context\n    private final ScreenOrientationModuleImpl moduleImpl;\n\n    public ScreenOrientationModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n        this.moduleImpl = new ScreenOrientationModuleImpl(reactContext);\n    }\n\n    // Return the name of the module - it should match the name provided in JS specification\n    @Override\n    public String getName() {\n        return ScreenOrientationModuleImpl.NAME;\n    }\n\n    @Override\n    public void initialize() {\n        super.initialize();\n        moduleImpl.onInitialize();\n    }\n\n    @Override\n    public void invalidate() {\n        moduleImpl.onInvalidate();\n        super.invalidate();\n    }\n\n    @Override\n    protected Map<String, Object> getTypedExportedConstants() {\n        final Map<String, Object> map = new HashMap<>();\n        map.put(PORTRAIT, PORTRAIT);\n        map.put(LANDSCAPE, LANDSCAPE);\n        return map;\n    }\n\n    @Override\n    public void addListener(String eventName) {}\n\n    @Override\n    public void removeListeners(double count) {}\n}\n')),(0,o.kt)("p",null,"Here we declare the ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," class.\nIt extends codegenerated spec class and takes ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactApplicationContext")," instance as constructor parameter.\nAdditionally, ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," is annotated with ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactModule")," decorator.\nStatic constant ",(0,o.kt)("inlineCode",{parentName:"p"},"NAME")," matches the value declared in JS specification."),(0,o.kt)("p",null,"To start/stop listening to orientation change events, we call ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," methods inside overriden ",(0,o.kt)("inlineCode",{parentName:"p"},"initialize")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"invalidate")," lifecycle methods."),(0,o.kt)("p",null,"Additionally, we have to add empty implementation for ",(0,o.kt)("inlineCode",{parentName:"p"},"addListener")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"removeListeners")," methods (to satisfy codegenerated spec base class)."),(0,o.kt)("p",null,"To export constants, we have to override ",(0,o.kt)("inlineCode",{parentName:"p"},"getTypedExportedConstants")," method which returns map of key-value pairs."),(0,o.kt)(c.ZP,{filename:"android/src/oldarch/java/com/screenorientationpackage/ScreenOrientationModule.java",language:"java",mdxType:"OldArchAndroidModuleFile"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'package com.screenorientationpackage;\n\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.module.annotations.ReactModule;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n* Declare Java class for old arch native module implementation\n*\n* Each native module extends ReactContextBaseJavaModule class\n*\n* Class should be annotated with @ReactModule decorator\n*/\n@ReactModule(name = ScreenOrientationModule.NAME)\npublic class ScreenOrientationModule extends ReactContextBaseJavaModule {\n    public static final String PORTRAIT = "PORTRAIT";\n    public static final String LANDSCAPE = "LANDSCAPE";\n    public static final String NAME = ScreenOrientationModuleImpl.NAME;\n\n    // Use shared module implementation and forward react application context\n    private final ScreenOrientationModuleImpl moduleImpl;\n\n    public ScreenOrientationModule(ReactApplicationContext reactContext) {\n        super(reactContext);\n        this.moduleImpl = new ScreenOrientationModuleImpl(reactContext);\n    }\n\n    // Return the name of the module - it should match the name provided in JS specification\n    @Override\n    public String getName() {\n        return ScreenOrientationModuleImpl.NAME;\n    }\n\n    @Override\n    public void initialize() {\n        super.initialize();\n        moduleImpl.onInitialize();\n    }\n\n    @Override\n    public void invalidate() {\n        moduleImpl.onInvalidate();\n        super.invalidate();\n    }\n\n    @Override\n    public Map<String, Object> getConstants() {\n        final Map<String, Object> map = new HashMap<>();\n        map.put(PORTRAIT, PORTRAIT);\n        map.put(LANDSCAPE, LANDSCAPE);\n        return map;\n    }\n\n    @ReactMethod\n    public void addListener(String eventName) {}\n\n    @ReactMethod\n    public void removeListeners(double count) {}\n}\n'))),(0,o.kt)("p",null,"Let's finalize it by exporting the module in the ",(0,o.kt)("inlineCode",{parentName:"p"},"TurboReactPackage")," instance."))}u.isMDXComponent=!0;const p={toc:[{value:"<code>ScreenOrientationModuleImpl.java</code>",id:"screenorientationmoduleimpljava",level:4}]},m="wrapper";function g(e){let{components:n,...t}=e;return(0,o.kt)(m,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h4",{id:"screenorientationmoduleimpljava"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModuleImpl.java")),(0,o.kt)("p",null,"Let's start by creating a small pure Java class that will be responsible for registering orientation listener:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="android/src/main/java/com/screenorientationpackage/ScreenOrientationModuleImpl.java"',title:'"android/src/main/java/com/screenorientationpackage/ScreenOrientationModuleImpl.java"'},'package com.screenorientationpackage;\n\nimport android.hardware.SensorManager;\nimport android.view.OrientationEventListener;\nimport com.facebook.react.bridge.Arguments;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.modules.core.DeviceEventManagerModule;\n\nimport java.util.Objects;\n\n/**\n * Native module\'s shared implementation\n */\npublic class ScreenOrientationModuleImpl {\n    private final ReactApplicationContext reactContext;\n\n    public static final String NAME = "ScreenOrientationModule";\n    public static final String EVENT_NAME = "onScreenOrientationModuleChange";\n    public static final String EVENT_KEY = "value";\n\n    public ScreenOrientationModuleImpl(ReactApplicationContext reactContext) {\n        this.reactContext = reactContext;\n    }\n\n    /**\n     * Example usage:\n     *\n     * ```java\n     * WritableMap payload = Arguments.createMap();\n     * payload.putDouble(EVENT_KEY, 42);\n     * sendEvent(EVENT_NAME, payload);\n     * ```\n     */\n    private void sendEvent(String eventName, WritableMap params) {\n        reactContext\n            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n            .emit(eventName, params);\n    }\n\n    private OrientationEventListener mOrientationDidChangeListener = null;\n    private String mLastOrientation = "unknown";\n\n    public void onInitialize() {\n        mOrientationDidChangeListener = new OrientationEventListener(reactContext, SensorManager.SENSOR_DELAY_NORMAL) {\n            @Override\n            public void onOrientationChanged(int orientation) {\n                String screenOrientation;\n                if (orientation > 315 || orientation < 45 || (orientation > 135 && orientation < 225)) {\n                    screenOrientation = "portrait";\n                } else {\n                    screenOrientation = "landscape";\n                }\n\n                if (Objects.equals(mLastOrientation, screenOrientation)) {\n                    return;\n                }\n                mLastOrientation = screenOrientation;\n\n                WritableMap payload = Arguments.createMap();\n                payload.putString("orientation", screenOrientation);\n                sendEvent(EVENT_NAME, payload);\n            }\n        };\n        mOrientationDidChangeListener.enable();\n    }\n\n    public void onInvalidate() {\n        if (mOrientationDidChangeListener != null) {\n            mOrientationDidChangeListener.disable();\n        }\n        mOrientationDidChangeListener = null;\n    }\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class declares two public methods responsible for registering/unregistering orientation listener.\nThe orientation listener has a logic inside ",(0,o.kt)("inlineCode",{parentName:"p"},"onOrientationChanged")," callback that checks if there's new orientation value to be emitted and, if yes, emits it to the JS world.\nTo listen to orientation changes, we're using ",(0,o.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/android/view/OrientationEventListener"},(0,o.kt)("inlineCode",{parentName:"a"},"OrientationEventListener"))," abstract class.\nTo emit events, we are using ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTDeviceEventEmitter")," class, to use it in a convienient way, we wrap it in ",(0,o.kt)("inlineCode",{parentName:"p"},"sendEvent")," helper method.\nThe payload of the event is created thanks to ",(0,o.kt)("inlineCode",{parentName:"p"},"Arguments.createMap")," utility helper."))}g.isMDXComponent=!0;const v={toc:[]},h="wrapper";function k(e){let{components:n,...t}=e;return(0,o.kt)(h,(0,a.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)(g,{mdxType:"AndroidJavaModuleImpl"}),(0,o.kt)(u,{mdxType:"AndroidJavaModule"}),(0,o.kt)(l.ZP,{language:"java",moduleClass:"ScreenOrientationModule",namespace:"screenorientationpackage",packageClass:"ScreenOrientationTurboPackage",mdxType:"AndroidTurboPackage"}))}k.isMDXComponent=!0;const M={toc:[{value:"<code>ScreenOrientationModule.kt</code>",id:"screenorientationmodulekt",level:4}]},b="wrapper";function f(e){let{components:n,...t}=e;return(0,o.kt)(b,(0,a.Z)({},M,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h4",{id:"screenorientationmodulekt"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModule.kt")),(0,o.kt)("p",null,"Now, let's move to the module class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/newarch/java/com/screenorientationpackage/ScreenOrientationModule.kt"',title:'"android/src/newarch/java/com/screenorientationpackage/ScreenOrientationModule.kt"'},'package com.screenorientationpackage\n\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.module.annotations.ReactModule\n\n/**\n * Declare Kotlin class for new arch native module implementation\n *\n * Each turbo module extends codegenerated spec class\n *\n * Class should be annotated with @ReactModule decorator\n */\n@ReactModule(name = ScreenOrientationModule.NAME)\nclass ScreenOrientationModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : NativeScreenOrientationModuleSpec(reactContext) {\n    // Use shared module implementation and forward react application context\n    private val moduleImpl = ScreenOrientationModuleImpl(reactContext)\n\n    // Return the name of the module - it should match the name provided in JS specification\n    override fun getName() = ScreenOrientationModuleImpl.NAME\n\n    override fun initialize() {\n        super.initialize()\n        moduleImpl.onInitialize()\n    }\n\n    override fun invalidate() {\n        moduleImpl.onInvalidate()\n        super.invalidate()\n    }\n\n    override fun getTypedExportedConstants(): MutableMap<String, Any> {\n        return mutableMapOf(\n            PORTRAIT to PORTRAIT,\n            LANDSCAPE to LANDSCAPE\n        )\n    }\n\n    override fun addListener(eventName: String?) = Unit\n\n    override fun removeListeners(count: Double) = Unit\n\n    companion object {\n        const val PORTRAIT = "PORTRAIT"\n        const val LANDSCAPE = "LANDSCAPE"\n        const val NAME = ScreenOrientationModuleImpl.NAME\n    }\n}\n')),(0,o.kt)("p",null,"Here we declare the ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," class.\nIt extends codegenerated spec class and takes ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactApplicationContext")," instance as constructor parameter.\nAdditionally, ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModule")," is annotated with ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactModule")," decorator.\nStatic constant ",(0,o.kt)("inlineCode",{parentName:"p"},"NAME")," matches the value declared in JS specification."),(0,o.kt)("p",null,"To start/stop listening to orientation change events, we call ",(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," methods inside overriden ",(0,o.kt)("inlineCode",{parentName:"p"},"initialize")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"invalidate")," lifecycle methods."),(0,o.kt)("p",null,"Additionally, we have to add empty implementation for ",(0,o.kt)("inlineCode",{parentName:"p"},"addListener")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"removeListeners")," methods (to satisfy codegenerated spec base class)."),(0,o.kt)("p",null,"To export constants, we have to override ",(0,o.kt)("inlineCode",{parentName:"p"},"getTypedExportedConstants")," method which returns map of key-value pairs."),(0,o.kt)(c.ZP,{filename:"android/src/oldarch/java/com/screenorientationpackage/ScreenOrientationModule.kt",language:"kotlin",mdxType:"OldArchAndroidModuleFile"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'package com.screenorientationpackage\n\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\nimport com.facebook.react.module.annotations.ReactModule\n\n/**\n* Declare Kotlin class for old arch native module implementation\n*\n* Each native module extends ReactContextBaseJavaModule class\n*\n* Class should be annotated with @ReactModule decorator\n*/\n@ReactModule(name = ScreenOrientationModule.NAME)\nclass ScreenOrientationModule(\n    // Each native module class consumes react application context\n    reactContext: ReactApplicationContext\n) : ReactContextBaseJavaModule(reactContext) {\n    // Use shared module implementation and forward react application context\n    private val moduleImpl = ScreenOrientationModuleImpl(reactContext)\n\n    // Return the name of the module - it should match the name provided in JS specification\n    override fun getName() = ScreenOrientationModuleImpl.NAME\n\n    override fun initialize() {\n        super.initialize()\n        moduleImpl.onInitialize()\n    }\n\n    override fun invalidate() {\n        moduleImpl.onInvalidate()\n        super.invalidate()\n    }\n\n    override fun getConstants(): MutableMap<String, Any> {\n        return mutableMapOf(\n            PORTRAIT to PORTRAIT,\n            LANDSCAPE to LANDSCAPE\n        )\n    }\n\n    @ReactMethod\n    fun addListener(eventName: String?) = Unit\n\n    @ReactMethod\n    fun removeListeners(count: Double) = Unit\n\n    companion object {\n        const val PORTRAIT = "PORTRAIT"\n        const val LANDSCAPE = "LANDSCAPE"\n        const val NAME = ScreenOrientationModuleImpl.NAME\n    }\n}\n'))),(0,o.kt)("p",null,"Let's finalize it by exporting the module in the ",(0,o.kt)("inlineCode",{parentName:"p"},"TurboReactPackage")," instance."))}f.isMDXComponent=!0;const C={toc:[{value:"<code>ScreenOrientationModuleImpl.kt</code>",id:"screenorientationmoduleimplkt",level:4}]},N="wrapper";function O(e){let{components:n,...t}=e;return(0,o.kt)(N,(0,a.Z)({},C,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h4",{id:"screenorientationmoduleimplkt"},(0,o.kt)("inlineCode",{parentName:"h4"},"ScreenOrientationModuleImpl.kt")),(0,o.kt)("p",null,"Let's start by creating a small pure Kotlin class that will be responsible for registering orientation listener:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="android/src/main/java/com/screenorientationpackage/ScreenOrientationModuleImpl.kt"',title:'"android/src/main/java/com/screenorientationpackage/ScreenOrientationModuleImpl.kt"'},'package com.screenorientationpackage\n\nimport android.hardware.SensorManager\nimport android.view.OrientationEventListener\nimport com.facebook.react.bridge.Arguments\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.WritableMap\nimport com.facebook.react.modules.core.DeviceEventManagerModule\n\n/**\n * Native module\'s shared implementation\n */\nclass ScreenOrientationModuleImpl(\n    private val reactContext: ReactApplicationContext\n) {\n    /**\n     * Example usage:\n     *\n     * ```kotlin\n     * sendEvent(EVENT_NAME, Arguments.createMap().apply {\n     *     putDouble(EVENT_KEY, 42)\n     * });\n     * ```\n     */\n    private fun sendEvent(eventName: String, params: WritableMap?) {\n        reactContext\n            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)\n            .emit(eventName, params)\n    }\n\n    private var mOrientationDidChangeListener: OrientationEventListener? = null\n    private var mLastOrientation = "unknown"\n\n    fun onInitialize() {\n        mOrientationDidChangeListener = object : OrientationEventListener(reactContext, SensorManager.SENSOR_DELAY_NORMAL) {\n            override fun onOrientationChanged(orientation: Int) {\n                val screenOrientation = if (orientation > 315 || orientation < 45 || (orientation in 135..225)) {\n                    "portrait"\n                } else {\n                    "landscape"\n                }\n\n                if (mLastOrientation == screenOrientation) {\n                    return\n                }\n                mLastOrientation = screenOrientation\n\n                sendEvent(EVENT_NAME, Arguments.createMap().apply {\n                    putString("orientation", screenOrientation)\n                })\n            }\n        }\n        mOrientationDidChangeListener?.enable()\n    }\n\n    fun onInvalidate() {\n        mOrientationDidChangeListener?.disable()\n        mOrientationDidChangeListener = null\n    }\n\n    companion object {\n        const val EVENT_NAME = "onScreenOrientationModuleChange"\n        const val EVENT_KEY = "value"\n        const val NAME = "ScreenOrientationModule"\n    }\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ScreenOrientationModuleImpl")," class declares two public methods responsible for registering/unregistering orientation listener.\nThe orientation listener has a logic inside ",(0,o.kt)("inlineCode",{parentName:"p"},"onOrientationChanged")," callback that checks if there's new orientation value to be emitted and, if yes, emits it to the JS world.\nTo listen to orientation changes, we're using ",(0,o.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/kotlin/android/view/OrientationEventListener"},(0,o.kt)("inlineCode",{parentName:"a"},"OrientationEventListener"))," abstract class.\nTo emit events, we are using ",(0,o.kt)("inlineCode",{parentName:"p"},"RCTDeviceEventEmitter")," class, to use it in a convienient way, we wrap it in ",(0,o.kt)("inlineCode",{parentName:"p"},"sendEvent")," helper method.\nThe payload of the event is created thanks to ",(0,o.kt)("inlineCode",{parentName:"p"},"Arguments.createMap")," utility helper."))}O.isMDXComponent=!0;const A={toc:[]},S="wrapper";function w(e){let{components:n,...t}=e;return(0,o.kt)(S,(0,a.Z)({},A,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)(O,{mdxType:"AndroidKotlinModuleImpl"}),(0,o.kt)(f,{mdxType:"AndroidKotlinModule"}),(0,o.kt)(l.ZP,{language:"kotlin",moduleClass:"ScreenOrientationModule",namespace:"screenorientationpackage",packageClass:"ScreenOrientationTurboPackage",mdxType:"AndroidTurboPackage"}))}w.isMDXComponent=!0;const E={sidebar_label:"Android implementation",sidebar_position:5,title:"Android implementation"},x=void 0,I={unversionedId:"guides/screen-orientation-module/android-impl",id:"guides/screen-orientation-module/android-impl",title:"Android implementation",description:"Let's use Android Studio for writing Android code. Launch Android Studio and open the project under /android path.",source:"@site/docs/guides/screen-orientation-module/android-impl.mdx",sourceDirName:"guides/screen-orientation-module",slug:"/guides/screen-orientation-module/android-impl",permalink:"/rnbridgingtutorial/docs/guides/screen-orientation-module/android-impl",draft:!1,editUrl:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/bridging-tutorial-website/docs/guides/screen-orientation-module/android-impl.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_label:"Android implementation",sidebar_position:5,title:"Android implementation"},sidebar:"tutorialSidebar",previous:{title:"iOS implementation",permalink:"/rnbridgingtutorial/docs/guides/screen-orientation-module/ios-impl"},next:{title:"Usage in practice",permalink:"/rnbridgingtutorial/docs/guides/screen-orientation-module/usage"}},T={},R=[],y={toc:R},L="wrapper";function D(e){let{components:n,...t}=e;return(0,o.kt)(L,(0,a.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Let's use Android Studio for writing Android code. Launch Android Studio and open the project under ",(0,o.kt)("inlineCode",{parentName:"p"},"<your-project-dir>/android")," path.\nWhen the project is opened, find ",(0,o.kt)("inlineCode",{parentName:"p"},"screen-orientation-package")," inside project-tree"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"screen-orientation-package")," contains 3 packages with the same name ",(0,o.kt)("inlineCode",{parentName:"p"},"com.screenorientationpackage"),". After expanding them, you'll notice that these contain following things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"code-generated Java spec files"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ScreenOrientationModule")," class stub files"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ScreenOrientationModuleImpl")," class stub file"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ScreenOrientationTurboPackage")," class stub file")),(0,o.kt)("p",null,"Let's start implementing!"),(0,o.kt)(i.Z,{groupId:"android_lang",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)(w,{mdxType:"AndroidKotlinImpl"})),(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(k,{mdxType:"AndroidJavaImpl"}))),(0,o.kt)("p",null,"You can check training repo for Kotlin implementation ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/screen-orientation-package"},"here")," and Java implementation ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/screen-orientation-package-classic"},"here"),"."),(0,o.kt)("p",null,"That's Android part, now let's wrap things up and try to ",(0,o.kt)("a",{parentName:"p",href:"./usage"},"use screen orientation module")," in action!"))}D.isMDXComponent=!0}}]);