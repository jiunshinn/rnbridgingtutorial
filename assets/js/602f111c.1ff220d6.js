"use strict";(self.webpackChunkbridging_tutorial_website=self.webpackChunkbridging_tutorial_website||[]).push([[2263],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>C});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(t),u=i,C=d["".concat(c,".").concat(u)]||d[u]||m[u]||o;return t?r.createElement(C,a(a({ref:n},p),{},{components:t})):r.createElement(C,a({ref:n},p))}));function C(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=u;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=t[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>a});var r=t(7294),i=t(6010);const o={tabItem:"tabItem_Ymn6"};function a(e){let{children:n,hidden:t,className:a}=e;return r.createElement("div",{role:"tabpanel",className:(0,i.Z)(o.tabItem,a),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>k});var r=t(7462),i=t(7294),o=t(6010),a=t(2466),l=t(6550),c=t(1980),s=t(7392),p=t(12);function d(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:i}}=e;return{value:n,label:t,attributes:r,default:i}}))}function m(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??d(t);return function(e){const n=(0,s.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function u(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function C(e){let{queryString:n=!1,groupId:t}=e;const r=(0,l.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c._X)(o),(0,i.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})}),[o,r])]}function w(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=m(e),[a,l]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:o}))),[c,s]=C({queryString:t,groupId:r}),[d,w]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,o]=(0,p.Nk)(t);return[r,(0,i.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:r}),h=(()=>{const e=c??d;return u({value:e,tabValues:o})?e:null})();(0,i.useLayoutEffect)((()=>{h&&l(h)}),[h]);return{selectedValue:a,selectValue:(0,i.useCallback)((e=>{if(!u({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),s(e),w(e)}),[s,w,o]),tabValues:o}}var h=t(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:n,block:t,selectedValue:l,selectValue:c,tabValues:s}=e;const p=[],{blockElementScrollPositionUntilNextRender:d}=(0,a.o5)(),m=e=>{const n=e.currentTarget,t=p.indexOf(n),r=s[t].value;r!==l&&(d(n),c(r))},u=e=>{let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=p.indexOf(e.currentTarget)+1;n=p[t]??p[0];break}case"ArrowLeft":{const t=p.indexOf(e.currentTarget)-1;n=p[t]??p[p.length-1];break}}n?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},s.map((e=>{let{value:n,label:t,attributes:a}=e;return i.createElement("li",(0,r.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>p.push(e),onKeyDown:u,onClick:m},a,{className:(0,o.Z)("tabs__item",g.tabItem,a?.className,{"tabs__item--active":l===n})}),t??n)})))}function y(e){let{lazy:n,children:t,selectedValue:r}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===r));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==r}))))}function b(e){const n=w(e);return i.createElement("div",{className:(0,o.Z)("tabs-container",g.tabList)},i.createElement(f,(0,r.Z)({},e,n)),i.createElement(y,(0,r.Z)({},e,n)))}function k(e){const n=(0,h.Z)();return i.createElement(b,(0,r.Z)({key:String(n)},e))}},3504:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>b,contentTitle:()=>f,default:()=>N,frontMatter:()=>g,metadata:()=>y,toc:()=>k});var r=t(7462),i=(t(7294),t(3905));t(4866),t(5162);const o={toc:[{value:"<code>ConicGradientViewComponentView.h</code>",id:"conicgradientviewcomponentviewh",level:4},{value:"<code>ConicGradientViewComponentView.mm</code>",id:"conicgradientviewcomponentviewmm",level:4}]},a="wrapper";function l(e){let{components:n,...t}=e;return(0,i.kt)(a,(0,r.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"conicgradientviewcomponentviewh"},(0,i.kt)("inlineCode",{parentName:"h4"},"ConicGradientViewComponentView.h")),(0,i.kt)("p",null,"Let's go to the header file for new architecture Fabric component at ",(0,i.kt)("inlineCode",{parentName:"p"},"ios/ConicGradientViewComponentView.h")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ConicGradientViewComponentView.h"',title:'"ios/ConicGradientViewComponentView.h"'},"#if RCT_NEW_ARCH_ENABLED\n#import <React/RCTViewComponentView.h>\n#import <QuartzCore/QuartzCore.h>\n\n/**\n * Declare the ObjC interface for that Fabric component class.\n * \n * It must extend RCTViewComponentView\n */\n@interface ConicGradientViewComponentView : RCTViewComponentView\n\n@property(nonatomic, readonly, strong) CAGradientLayer * _Nonnull layer;\n\n@end\n\n#endif\n")),(0,i.kt)("p",null,"We declare the class that extends ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTViewComponentView")," base class.\nYou can notice, that ",(0,i.kt)("inlineCode",{parentName:"p"},"layer")," property is declared - it's imported from ",(0,i.kt)("inlineCode",{parentName:"p"},"QuartzCore")," framework and will be responsible for displaying our gradient background."),(0,i.kt)("h4",{id:"conicgradientviewcomponentviewmm"},(0,i.kt)("inlineCode",{parentName:"h4"},"ConicGradientViewComponentView.mm")),(0,i.kt)("p",null,"Navigate to ",(0,i.kt)("inlineCode",{parentName:"p"},"ios/ConicGradientViewComponentView.mm")," where we'll implement our Fabric component."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ConicGradientViewComponentView.mm"',title:'"ios/ConicGradientViewComponentView.mm"'},'#if RCT_NEW_ARCH_ENABLED\n#import "ConicGradientViewComponentView.h"\n\n#import <React/RCTConversions.h>\n#import <RCTTypeSafety/RCTConvertHelpers.h>\n\n#import <react/renderer/components/ConicGradientPackage/ComponentDescriptors.h>\n#import <react/renderer/components/ConicGradientPackage/EventEmitters.h>\n#import <react/renderer/components/ConicGradientPackage/Props.h>\n#import <react/renderer/components/ConicGradientPackage/RCTComponentViewHelpers.h>\n\n#import "RCTFabricComponentsPlugins.h"\n\nusing namespace facebook::react;\n\n@interface ConicGradientViewComponentView () <RCTConicGradientViewViewProtocol>\n@end\n\n@implementation ConicGradientViewComponentView\n\n@dynamic layer;\n\n+ (Class)layerClass\n{\n    return [CAGradientLayer classForCoder];\n}\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        static const auto defaultProps = std::make_shared<const ConicGradientViewProps>();\n        _props = defaultProps;\n        \n        self.layer.type = kCAGradientLayerConic;\n        self.layer.needsDisplayOnBoundsChange = YES;\n    }\n\n    return self;\n}\n\n+ (ComponentDescriptorProvider)componentDescriptorProvider\n{\n    return concreteComponentDescriptorProvider<ConicGradientViewComponentDescriptor>();\n}\n\n@end\n\nClass<RCTComponentViewProtocol> ConicGradientViewCls(void)\n{\n    return ConicGradientViewComponentView.class;\n}\n#endif\n')),(0,i.kt)("p",null,"Here we start with a bunch of imports for conversion helpers and code-generated spec classes.\nNext up, we import ",(0,i.kt)("inlineCode",{parentName:"p"},"facebook::react")," C++ namespace to not write it every time before C++ classes which belong to that namespace.\nAfter that, we implement code-generated ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTConicGradientViewViewProtocol")," protocol."),(0,i.kt)("p",null,"Inside the implementation block, you can find ",(0,i.kt)("inlineCode",{parentName:"p"},"@dynamic layer;")," line. This will make the ",(0,i.kt)("inlineCode",{parentName:"p"},"layer")," property be able to be implemented at runtime and not at compile time.\nAnd this will be done at runtime with ",(0,i.kt)("inlineCode",{parentName:"p"},"+ layerClass")," getter that returns the class type for our layer (",(0,i.kt)("inlineCode",{parentName:"p"},"CAGradientLayer")," in that case).\nFor more reference about the gradient class, check out ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/quartzcore/cagradientlayer?language=objc"},(0,i.kt)("inlineCode",{parentName:"a"},"CAGradientLayer")," docs section"),"."),(0,i.kt)("p",null,"In the class ",(0,i.kt)("inlineCode",{parentName:"p"},"- initWithFrame:")," initializer we are declaring default props used by the component as well as gradient-layer's properties."),(0,i.kt)("p",null,"Each Fabric component needs to declare static ",(0,i.kt)("inlineCode",{parentName:"p"},"componentDescriptorProvider")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTComponentViewProtocol")," class type (here it's ",(0,i.kt)("inlineCode",{parentName:"p"},"ConicGradientViewCls"),")."),(0,i.kt)("p",null,"When our Fabric component has its boilerplate, we can start with adding support for gradient props - let's add ",(0,i.kt)("inlineCode",{parentName:"p"},"- updateProps:oldProps:")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ConicGradientViewComponentView.mm"',title:'"ios/ConicGradientViewComponentView.mm"'},"// ...\n\n@implementation ConicGradientViewComponentView\n\n// ...\n\n// highlight-start\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n    const auto &oldViewProps = *std::static_pointer_cast<const ConicGradientViewProps>(_props);\n    const auto &newViewProps = *std::static_pointer_cast<const ConicGradientViewProps>(props);\n\n    if (oldViewProps.colors != newViewProps.colors) {\n        auto colors = RCTConvertVecToArray(newViewProps.colors, ^id(SharedColor item){\n            return (id)RCTUIColorFromSharedColor(item).CGColor;\n        });\n        self.layer.colors = colors;\n    }\n\n    if (oldViewProps.locations != newViewProps.locations) {\n        auto locations = RCTConvertVecToArray(newViewProps.locations, ^id(double item){\n            return @(item);\n        });\n        self.layer.locations = locations;\n    }\n\n    if (oldViewProps.centerPoint.x != newViewProps.centerPoint.x || oldViewProps.centerPoint.y != newViewProps.centerPoint.y) {\n        auto centerPoint = CGPointMake(newViewProps.centerPoint.x, newViewProps.centerPoint.y);\n        self.layer.startPoint = centerPoint;\n        self.layer.endPoint = CGPointMake(1, centerPoint.y);\n    }\n\n    [super updateProps:props oldProps:oldProps];\n}\n// highlight-end\n\n// ...\n\n@end\n\n// ...\n")),(0,i.kt)("p",null,"The newly added method is responsible for comparing new and old props and updating our component's gradient layer if needed.\nFor first two props, we are using ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTConvertVecToArray")," helper to map C++ array to Objective-C array.\nAdditionally, C++ SharedColor type is mapped here to Objective-C ",(0,i.kt)("inlineCode",{parentName:"p"},"UIColor")," thanks to ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTUIColorFromSharedColor")," helper."))}l.isMDXComponent=!0;const c={toc:[{value:"<code>ConicGradientView.h</code>",id:"conicgradientviewh",level:4},{value:"<code>ConicGradientView.mm</code>",id:"conicgradientviewmm",level:4}]},s="wrapper";function p(e){let{components:n,...t}=e;return(0,i.kt)(s,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"conicgradientviewh"},(0,i.kt)("inlineCode",{parentName:"h4"},"ConicGradientView.h")),(0,i.kt)("p",null,"Next step is to implement similar experience for the old architecture component - to do that, let's go to ",(0,i.kt)("inlineCode",{parentName:"p"},"ios/ConicGradientView.h")," and declare a class that extends ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTView"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ConicGradientView.h"',title:'"ios/ConicGradientView.h"'},"#import <UIKit/UIKit.h>\n#import <QuartzCore/QuartzCore.h>\n#import <React/RCTView.h>\n\n/**\n * Declare the ObjC interface for that old arch component class.\n * \n * If it needs to be enhanced `<View />`, it will extend `RCTView`, otherwise it can extend any UIView-based class.\n */\n@interface ConicGradientView : RCTView\n\n@property(nonatomic, readonly, strong) CAGradientLayer * _Nonnull layer;\n\n@property (nonatomic, copy) NSArray<UIColor *> * _Nonnull colors;\n@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull locations;\n@property (nonatomic, assign) CGPoint centerPoint;\n\n@end\n")),(0,i.kt)("p",null,"As in the Fabric component, we declare the ",(0,i.kt)("inlineCode",{parentName:"p"},"layer")," property.\nAlso we have to declare each prop that will be transferred from JS world."),(0,i.kt)("h4",{id:"conicgradientviewmm"},(0,i.kt)("inlineCode",{parentName:"h4"},"ConicGradientView.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ConicGradientView.mm"',title:'"ios/ConicGradientView.mm"'},'#import "ConicGradientView.h"\n\n@implementation ConicGradientView\n\n@dynamic layer;\n\n+ (Class)layerClass\n{\n    return [CAGradientLayer classForCoder];\n}\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self) {\n        [self setup];\n    }\n    return self;\n}\n\n- (void)setup\n{\n    self.layer.type = kCAGradientLayerConic;\n    self.layer.needsDisplayOnBoundsChange = YES;\n}\n\n- (void)setColors:(NSArray<UIColor *> *)colors\n{\n    _colors = colors;\n    NSMutableArray *cgColors = [NSMutableArray arrayWithCapacity:colors.count];\n    for (int i = 0; i < colors.count; i++) {\n        cgColors[i] = (id)colors[i].CGColor;\n    }\n    self.layer.colors = cgColors;\n}\n\n- (void)setLocations:(NSArray<NSNumber *> *)locations\n{\n    _locations = locations;\n    self.layer.locations = locations;\n}\n\n- (void)setCenterPoint:(CGPoint)centerPoint\n{\n    _centerPoint = centerPoint;\n    self.layer.startPoint = centerPoint;\n    self.layer.endPoint = CGPointMake(1, centerPoint.y);\n}\n\n@end\n')),(0,i.kt)("p",null,"Gradient class is returned from ",(0,i.kt)("inlineCode",{parentName:"p"},"+ layerClass")," static function that is used to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"layer")," property,\nwe setup the gradient layer type in the initializer and we handle gradient configuration when props are changed."))}p.isMDXComponent=!0;const d={toc:[{value:"<code>ConicGradientViewManager.h</code>",id:"conicgradientviewmanagerh",level:4},{value:"<code>ConicGradientViewManager.mm</code>",id:"conicgradientviewmanagermm",level:4}]},m="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"conicgradientviewmanagerh"},(0,i.kt)("inlineCode",{parentName:"h4"},"ConicGradientViewManager.h")),(0,i.kt)("p",null,"Let's navigate to ",(0,i.kt)("inlineCode",{parentName:"p"},"ios/ConicGradientViewManager.h")," - the header file for the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConicGradientViewManager")," view manager class. It will extend ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTViewManager")," class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ConicGradientViewManager.h',title:'"ios/ConicGradientViewManager.h'},"#import <React/RCTViewManager.h>\n\n/**\n * Declare the ObjC interface for that view manager class.\n * \n * It must extend RCTViewManager\n */\n@interface ConicGradientViewManager : RCTViewManager\n\n@end\n")),(0,i.kt)("h4",{id:"conicgradientviewmanagermm"},(0,i.kt)("inlineCode",{parentName:"h4"},"ConicGradientViewManager.mm")),(0,i.kt)("p",null,"Wrap everything up in ",(0,i.kt)("inlineCode",{parentName:"p"},"ios/ConicGradientViewManager.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/ConicGradientViewManager.mm"',title:'"ios/ConicGradientViewManager.mm"'},'#import "ConicGradientViewManager.h"\n\n#if RCT_NEW_ARCH_ENABLED\n#else\n#import "ConicGradientView.h"\n#endif\n\n@implementation ConicGradientViewManager\n\nRCT_EXPORT_MODULE(ConicGradientView)\n\nRCT_EXPORT_VIEW_PROPERTY(colors, NSArray<UIColor>)\nRCT_EXPORT_VIEW_PROPERTY(locations, NSArray<NSNumber *>)\nRCT_EXPORT_VIEW_PROPERTY(centerPoint, CGPoint)\n\n#if RCT_NEW_ARCH_ENABLED\n#else\n- (UIView *)view\n{\n    ConicGradientView *view = [ConicGradientView new];\n    return view;\n}\n#endif\n\n@end\n')),(0,i.kt)("p",null,"In the implementation file for ",(0,i.kt)("inlineCode",{parentName:"p"},"ConicGradientViewManager")," class we use ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro with the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConicGradientView")," name that will be accessed on the JS side.\nThe props are declared with ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_VIEW_PROPERTY")," macro (1st arg - name of the prop; 2nd arg - its native type).\nAdditionally, we are declaring managed view for the old architecture mode - for the new architecture mode, we just need to register the name of our module and the props it accepts."))}u.isMDXComponent=!0;const C={toc:[]},w="wrapper";function h(e){let{components:n,...t}=e;return(0,i.kt)(w,(0,r.Z)({},C,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(l,{mdxType:"IosObjCComponentView"}),(0,i.kt)(p,{mdxType:"IosObjCView"}),(0,i.kt)(u,{mdxType:"IosObjCViewManager"}))}h.isMDXComponent=!0;const g={sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},f=void 0,y={unversionedId:"guides/conic-gradient-view/ios-impl",id:"guides/conic-gradient-view/ios-impl",title:"iOS implementation",description:"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:",source:"@site/docs/guides/conic-gradient-view/ios-impl.mdx",sourceDirName:"guides/conic-gradient-view",slug:"/guides/conic-gradient-view/ios-impl",permalink:"/rnbridgingtutorial/docs/guides/conic-gradient-view/ios-impl",draft:!1,editUrl:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/docs/docs/guides/conic-gradient-view/ios-impl.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},sidebar:"tutorialSidebar",previous:{title:"JS specification",permalink:"/rnbridgingtutorial/docs/guides/conic-gradient-view/js-spec"},next:{title:"Android implementation",permalink:"/rnbridgingtutorial/docs/guides/conic-gradient-view/android-impl"}},b={},k=[],V={toc:k},v="wrapper";function N(e){let{components:n,...t}=e;return(0,i.kt)(v,(0,r.Z)({},V,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"xed ios\n")),(0,i.kt)("p",null,"When workspace is opened, locate ",(0,i.kt)("inlineCode",{parentName:"p"},"Pods")," project and expand it. Search for ",(0,i.kt)("inlineCode",{parentName:"p"},"Development Pods")," and find ",(0,i.kt)("inlineCode",{parentName:"p"},"ConicGradientPackage")," inside. When it's expanded, it will show all files that we created under ",(0,i.kt)("inlineCode",{parentName:"p"},"conic-gradient-package/ios")," directory."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Extending the ",(0,i.kt)("inlineCode",{parentName:"p"},"<View />")," is available only in Objective-C")),(0,i.kt)(h,{mdxType:"IosObjCImpl"}),(0,i.kt)("p",null,"You can check training repo for Objective-C-only implementation ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/conic-gradient-package"},"here"),"."),(0,i.kt)("p",null,"That's iOS part, now let's go to Android!"))}N.isMDXComponent=!0}}]);