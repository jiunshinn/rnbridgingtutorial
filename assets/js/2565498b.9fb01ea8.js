"use strict";(self.webpackChunkbridging_tutorial_website=self.webpackChunkbridging_tutorial_website||[]).push([[2924],{5162:(e,n,t)=>{t.d(n,{Z:()=>a});var l=t(7294),i=t(6010);const o={tabItem:"tabItem_Ymn6"};function a(e){let{children:n,hidden:t,className:a}=e;return l.createElement("div",{role:"tabpanel",className:(0,i.Z)(o.tabItem,a),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>C});var l=t(7462),i=t(7294),o=t(6010),a=t(2466),r=t(6550),c=t(1980),s=t(7392),d=t(12);function m(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:l,default:i}}=e;return{value:n,label:t,attributes:l,default:i}}))}function u(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??m(t);return function(e){const n=(0,s.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function k(e){let{queryString:n=!1,groupId:t}=e;const l=(0,r.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c._X)(o),(0,i.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(l.location.search);n.set(o,e),l.replace({...l.location,search:n.toString()})}),[o,l])]}function h(e){const{defaultValue:n,queryString:t=!1,groupId:l}=e,o=u(e),[a,r]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const l=t.find((e=>e.default))??t[0];if(!l)throw new Error("Unexpected error: 0 tabValues");return l.value}({defaultValue:n,tabValues:o}))),[c,s]=k({queryString:t,groupId:l}),[m,h]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[l,o]=(0,d.Nk)(t);return[l,(0,i.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:l}),v=(()=>{const e=c??m;return p({value:e,tabValues:o})?e:null})();(0,i.useLayoutEffect)((()=>{v&&r(v)}),[v]);return{selectedValue:a,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);r(e),s(e),h(e)}),[s,h,o]),tabValues:o}}var v=t(2389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:n,block:t,selectedValue:r,selectValue:c,tabValues:s}=e;const d=[],{blockElementScrollPositionUntilNextRender:m}=(0,a.o5)(),u=e=>{const n=e.currentTarget,t=d.indexOf(n),l=s[t].value;l!==r&&(m(n),c(l))},p=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},s.map((e=>{let{value:n,label:t,attributes:a}=e;return i.createElement("li",(0,l.Z)({role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,key:n,ref:e=>d.push(e),onKeyDown:p,onClick:u},a,{className:(0,o.Z)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":r===n})}),t??n)})))}function b(e){let{lazy:n,children:t,selectedValue:l}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===l));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==l}))))}function S(e){const n=h(e);return i.createElement("div",{className:(0,o.Z)("tabs-container",f.tabList)},i.createElement(g,(0,l.Z)({},e,n)),i.createElement(b,(0,l.Z)({},e,n)))}function C(e){const n=(0,v.Z)();return i.createElement(S,(0,l.Z)({key:String(n)},e))}},6162:(e,n,t)=>{t.d(n,{ZP:()=>c});var l=t(7462),i=(t(7294),t(3905)),o=t(814);const a={toc:[]},r="wrapper";function c(e){let{components:n,...t}=e;return(0,i.kt)(r,(0,l.Z)({},a,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Complete ",(0,i.kt)("code",null,t.filename)," file"),(0,i.kt)("div",null,(0,i.kt)(o.Z,{language:t.language,mdxType:"CodeBlock"},t.children))))}c.isMDXComponent=!0},5403:(e,n,t)=>{t.d(n,{ZP:()=>r});var l=t(7462),i=(t(7294),t(3905));const o={toc:[]},a="wrapper";function r(e){let{components:n,...t}=e;return(0,i.kt)(a,(0,l.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"To make Swift elements accessible to ObjC world, we have to do 4 things:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"make class extending ",(0,i.kt)("inlineCode",{parentName:"li"},"NSObject")),(0,i.kt)("li",{parentName:"ul"},"mark class and its methods (at least those methods that are meant to be exposed) as public"),(0,i.kt)("li",{parentName:"ul"},"mark class with ",(0,i.kt)("inlineCode",{parentName:"li"},"@objc(exported-objc-name)")," decorator"),(0,i.kt)("li",{parentName:"ul"},"mark exposed methods with ",(0,i.kt)("inlineCode",{parentName:"li"},"@objc")," decorator"))))}r.isMDXComponent=!0},5061:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>T,contentTitle:()=>F,default:()=>j,frontMatter:()=>I,metadata:()=>R,toc:()=>E});var l=t(7462),i=(t(7294),t(3905)),o=t(4866),a=t(5162),r=t(6162);const c={toc:[{value:"<code>SaveFilePickerModule.h</code>",id:"savefilepickermoduleh",level:4},{value:"<code>SaveFilePickerModule.mm</code>",id:"savefilepickermodulemm",level:4}]},s="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(s,(0,l.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"savefilepickermoduleh"},(0,i.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModule.h")),(0,i.kt)("p",null,"Now, let's move to the module that will manage function calls from the JS world:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePicker.h"',title:'"ios/SaveFilePicker.h"'},"#import <React/RCTBridgeModule.h>\n\n/**\n * Declare the ObjC interface for that native module class.\n * \n * It must extend NSObject (like every class in ObjC) and\n * implement RCTBridgeModule (like each RN native module).\n * \n * If the module emits events, it must extend RCTEventEmitter class.\n */\n@interface SaveFilePickerModule : NSObject<RCTBridgeModule>\n\n@end\n")),(0,i.kt)("p",null,"In the header file for ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," class we declare our class extending ",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject")," (as every class in ObjC) and implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTBridgeModule")," (as each RN iOS module class)."),(0,i.kt)("h4",{id:"savefilepickermodulemm"},(0,i.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModule.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},'#import "SaveFilePickerModule.h"\n\n#import "SaveFilePickerModuleImpl.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "SaveFilePickerPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface SaveFilePickerModule () <NativeSaveFilePickerModuleSpec>\n@end\n#endif\n\n// Declare the ObjC implementation for that native module class\n@implementation SaveFilePickerModule\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(SaveFilePickerModule)\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeSaveFilePickerModuleSpecJSI>(params);\n}\n#endif\n\n@end\n')),(0,i.kt)("p",null,"This is the implementation file for ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," class."),(0,i.kt)("p",null,"Before declaring the implementation block, we have to import header file for ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," module-implementation class,\nand we have to implement code-generated spec protocol for new architecture (code between ",(0,i.kt)("inlineCode",{parentName:"p"},"#if RCT_NEW_ARCH_ENABLED")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif")," directives)."),(0,i.kt)("p",null,"After that, inside implementation block we have ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro invoked with ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," argument. This basically registers the module with provided name on iOS side, so that it's accessible in the JS world."),(0,i.kt)("p",null,"Also, for new architecture, it implements ",(0,i.kt)("inlineCode",{parentName:"p"},"- getTurboModule:")," method (from ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTTurboModule")," protocol).\nIf you won't implement that method, XCode will complain that the code-generated spec protocol methods are not implemented."),(0,i.kt)("p",null,"Let's combine module-implementation with module class"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},"//\n\n// highlight-start\n@interface SaveFilePickerModule () <SaveFilePickerModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n// highlight-end\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(SaveFilePickerModule)\n\n// highlight-start\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [SaveFilePickerModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return YES;\n}\n\n/**\n * If the module interacts with UIKit,\n * it can declare that its methods should be run on main queue\n */\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n// highlight-end\n\n//\n\n@end\n")),(0,i.kt)("p",null,"First, we declare private variable on ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," for module-implementation which will be initialized in the ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," method.\nWe can use ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl")," ObjC class, because it's imported from ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl.h"),"."),(0,i.kt)("p",null,"We also declared private variables for callback and promise blocks, we will use them to communicate result back to the JS code."),(0,i.kt)("p",null,"Next, we override static method ",(0,i.kt)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup"),", which must be done whenever ",(0,i.kt)("inlineCode",{parentName:"p"},"- init")," method on the RN's wrapper class is overriden. "),(0,i.kt)("p",null,"As we will interact with the UIKit API, we will need to do it on the main queue.\nWe could just wrap UIKit code in ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch_async(dispatch_get_main_queue(), ^{ ... });"),",\nbut there's also an option to specify the ",(0,i.kt)("inlineCode",{parentName:"p"},"- methodQueue")," getter.\nIt's used to describe on which queue this module calls should be run.\nSo in our case, we will want to use the main queue - returning ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch_get_main_queue()")," from the getter will do the job."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"To learn more about dispatch queues in ObjC, you may visit Apple's ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html"},"dedicated guide"),".")),(0,i.kt)("p",null,"We still have 2 things to do - as you may noticed, XCode displayed a warning about ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleDelegate"),".\nThe module class is marked to be implementing the delegate protocol,\nthe module-implementation's delegate property is set to this module instance,\nbut we still need to implement delegate's methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},'//\n\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n\n//\n\n/**\n * If the module interacts with UIKit,\n * it can declare that its methods should be run on main queue\n */\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n\n// highlight-start\n- (void)onSuccess\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(YES), @"cancelled": @(NO) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(YES));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onCancel\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(YES) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(NO));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onError:(NSError *)error\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(NO), @"error": @{ @"code": @(error.code), @"message": error.localizedDescription } }]);\n    } else if (rejectBlock != nil) {\n        rejectBlock([NSString stringWithFormat:@"%@", @(error.code)], error.localizedDescription, error);\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n// highlight-end\n\n@end\n')),(0,i.kt)("p",null,"In the delegate's methods, we are invoking callback/promise response blocks, with the result arguments.\nAs a cleanup, we are setting response blocks to ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),", so that these are not called second time."),(0,i.kt)("p",null,"The last thing is to export the methods to the JS layer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},'//\n\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n\n//\n\n/**\n * If the module interacts with UIKit,\n * it can declare that its methods should be run on main queue\n */\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n\n// highlight-start\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_METHOD(saveFileWithCallback : (NSString *)filename\n                              callback : (RCTResponseSenderBlock)callback)\n{\n    callbackBlock = callback;\n    [moduleImpl saveFileWithFilename:filename];\n}\n\nRCT_EXPORT_METHOD(saveFileWithPromise : (NSString *)filename\n                              resolve : (RCTPromiseResolveBlock)resolve\n                               reject : (RCTPromiseRejectBlock)reject)\n{\n    resolveBlock = resolve;\n    rejectBlock = reject;\n    [moduleImpl saveFileWithFilename:filename];\n}\n// highlight-end\n\n- (void)onSuccess\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(YES), @"cancelled": @(NO) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(YES));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onCancel\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(YES) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(NO));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onError:(NSError *)error\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(NO), @"error": @{ @"code": @(error.code), @"message": error.localizedDescription } }]);\n    } else if (rejectBlock != nil) {\n        rejectBlock([NSString stringWithFormat:@"%@", @(error.code)], error.localizedDescription, error);\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n@end\n')),(0,i.kt)("p",null,"Inside exported methods, we are doing 2 things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"we save callback/promise response blocks"),(0,i.kt)("li",{parentName:"ul"},"we use module-implementation to show the picker")),(0,i.kt)(r.ZP,{filename:"SaveFilePickerModule.mm",language:"objc",mdxType:"CompleteFile"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#import "SaveFilePickerModule.h"\n\n#import "SaveFilePickerModuleImpl.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "SaveFilePickerPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface SaveFilePickerModule () <NativeSaveFilePickerModuleSpec>\n@end\n#endif\n\n@interface SaveFilePickerModule () <SaveFilePickerModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(SaveFilePickerModule)\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [SaveFilePickerModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return YES;\n}\n\n/**\n* If the module interacts with UIKit,\n* it can declare that its methods should be run on main queue\n*/\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_METHOD(saveFileWithCallback : (NSString *)filename\n                              callback : (RCTResponseSenderBlock)callback)\n{\n    callbackBlock = callback;\n    [moduleImpl saveFileWithFilename:filename];\n}\n\nRCT_EXPORT_METHOD(saveFileWithPromise : (NSString *)filename\n                              resolve : (RCTPromiseResolveBlock)resolve\n                               reject : (RCTPromiseRejectBlock)reject)\n{\n    resolveBlock = resolve;\n    rejectBlock = reject;\n    [moduleImpl saveFileWithFilename:filename];\n}\n\n- (void)onSuccess\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(YES), @"cancelled": @(NO) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(YES));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onCancel\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(YES) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(NO));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onError:(NSError *)error\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(NO), @"error": @{ @"code": @(error.code), @"message": error.localizedDescription } }]);\n    } else if (rejectBlock != nil) {\n        rejectBlock([NSString stringWithFormat:@"%@", @(error.code)], error.localizedDescription, error);\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeSaveFilePickerModuleSpecJSI>(params);\n}\n#endif\n\n@end\n'))))}d.isMDXComponent=!0;const m={toc:[{value:"<code>SaveFilePickerModuleImpl.h</code>",id:"savefilepickermoduleimplh",level:4},{value:"<code>SaveFilePickerModuleImpl.mm</code>",id:"savefilepickermoduleimplmm",level:4}]},u="wrapper";function p(e){let{components:n,...t}=e;return(0,i.kt)(u,(0,l.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"savefilepickermoduleimplh"},(0,i.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModuleImpl.h")),(0,i.kt)("p",null,"Let's start by creating a module-implementation that will be used by our module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModuleImpl.h"',title:'"ios/SaveFilePickerModuleImpl.h"'},"#import <UIKit/UIKit.h>\n\n@protocol SaveFilePickerModuleDelegate\n\n- (void)onCancel;\n- (void)onError:(NSError *)error;\n- (void)onSuccess;\n\n@end\n\n@interface SaveFilePickerModuleImpl : NSObject\n\n@property (nonatomic, weak) id<SaveFilePickerModuleDelegate> delegate;\n\n- (void)saveFileWithFilename:(NSString *)filename;\n\n@end\n")),(0,i.kt)("p",null,"Here, we declare ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," class together with ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleDelegate")," protocol."),(0,i.kt)("p",null,"The class will have weak delegate property and one method."),(0,i.kt)("p",null,"For saving file functionality we will use ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidocumentpickerviewcontroller?language=objc"},(0,i.kt)("inlineCode",{parentName:"a"},"UIDocumentPickerViewController")),",\nmore specifically its ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidocumentpickerviewcontroller/3566733-initforopeningcontenttypes?language=objc"},(0,i.kt)("inlineCode",{parentName:"a"},"- initForOpeningContentTypes:asCopy:"))," initializer."),(0,i.kt)("p",null,"And to consume the result from the picker, the module-implementation class needs to implement ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidocumentpickerdelegate?language=objc"},(0,i.kt)("inlineCode",{parentName:"a"},"UIDocumentPickerDelegate")),"."),(0,i.kt)("h4",{id:"savefilepickermoduleimplmm"},(0,i.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModuleImpl.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/SaveFilePickerModuleImpl.mm"',title:'"ios/SaveFilePickerModuleImpl.mm"'},'#import "SaveFilePickerModuleImpl.h"\n\n#import <React/RCTUtils.h>\n\n@interface SaveFilePickerModuleImpl () <UIDocumentPickerDelegate>\n@end\n\n/**\n * Native module\'s shared implementation\n */\n@implementation SaveFilePickerModuleImpl\n\nstatic NSString *INVALID_PATH_ERROR_MESSAGE = @"Invalid path";\nstatic NSString *NO_VIEW_CONTROLLER_ERROR_MESSAGE = @"No viewcontroller";\n\n- (void)saveFileWithFilename:(NSString *)filename\n{\n    NSArray<NSString *> *filenameComponents = [filename componentsSeparatedByString:@"."];\n    NSURL *url = [[NSBundle mainBundle] URLForResource:filenameComponents[0] withExtension:filenameComponents[1]];\n    if (url == nil) {\n        [self.delegate onError:[NSError errorWithDomain:@"SaveFilePickerModuleImpl"\n                                                   code:1234\n                                               userInfo:@{ NSLocalizedDescriptionKey: INVALID_PATH_ERROR_MESSAGE }]];\n        return;\n    }\n\n    UIViewController *_Nullable presentedViewController = RCTPresentedViewController();\n    if (presentedViewController == nil) {\n        [self.delegate onError:[NSError errorWithDomain:@"SaveFilePickerModuleImpl"\n                                                   code:1234\n                                               userInfo:@{ NSLocalizedDescriptionKey: NO_VIEW_CONTROLLER_ERROR_MESSAGE }]];\n        return;\n    }\n    \n    UIDocumentPickerViewController *documentPicker = [self createDocumentPickerWithUrl:url];\n    documentPicker.delegate = self;\n    [presentedViewController presentViewController:documentPicker animated:YES completion:nil];\n}\n\n- (void)documentPicker:(UIDocumentPickerViewController *)controller didPickDocumentsAtURLs:(NSArray<NSURL *> *)urls\n{\n    [self.delegate onSuccess];\n    controller.delegate = nil;\n}\n\n- (void)documentPickerWasCancelled:(UIDocumentPickerViewController *)controller\n{\n    [self.delegate onCancel];\n    controller.delegate = nil;\n}\n\n- (UIDocumentPickerViewController *)createDocumentPickerWithUrl:(NSURL *)url\n{\n    if (@available(iOS 14.0, *)) {\n        return [[UIDocumentPickerViewController alloc] initForExportingURLs:@[url] asCopy:true];\n    }\n    return [[UIDocumentPickerViewController alloc] initWithURL:url inMode:UIDocumentPickerModeExportToService];\n}\n\n@end\n')),(0,i.kt)("p",null,"First take a look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"UIDocumentPickerDelegate")," implementation - we are implementing two methods (",(0,i.kt)("inlineCode",{parentName:"p"},"- documentPicker:didPickDocumentsAtURLs:")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"- documentPickerWasCancelled:"),"),\none is returning the urls where the file was saved and the other is called when user cancelled the picker.\nIn those methods, we have to call ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleDelegate")," delegate to communicate success or cancellation.\nWhen it's done, the picker's delegate ",(0,i.kt)("inlineCode",{parentName:"p"},"controller.delegate")," needs to be cleared."),(0,i.kt)("p",null,"Now we can start implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"- saveFileWithFilename:")," method.\nWe begin with getting the URL for the file from assets based on the ",(0,i.kt)("inlineCode",{parentName:"p"},"filename")," argument.\nIf it cannot be obtained, we have to early-return and communicate to the delegate, that there's no such file with that path."),(0,i.kt)("p",null,"Next step is to take currently presented view controller - will use it to modally display the file picker.\nAs with the url, we also have to do error handling for the case when there's no presented view controller (~0.001% chance, but we should still do it)."),(0,i.kt)("p",null,"Finally, we create the picker and present it modally. To create the picker we are using ",(0,i.kt)("inlineCode",{parentName:"p"},"- createDocumentPicker")," helper.\nIt's because the initializer we want to use is available from iOS 14, but our package declares support down to iOS 13.\nTo handle it, we are using availability check (",(0,i.kt)("inlineCode",{parentName:"p"},"if (@available)"),") to use new initilaizer for iOS 14+ and fall back to old initializer for iOS 13."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"For more on availability API, you can visit Apple ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/marking-api-availability-in-objective-c#Check-Availability"},"dedicated docs's section"),".")),(0,i.kt)("p",null,"When the picker is initialized, we have to set its delegate property to this module instance and present it."))}p.isMDXComponent=!0;const k={toc:[]},h="wrapper";function v(e){let{components:n,...t}=e;return(0,i.kt)(h,(0,l.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(p,{mdxType:"IosObjCModuleImpl"}),(0,i.kt)(d,{mdxType:"IosObjCModule"}))}v.isMDXComponent=!0;const f={toc:[{value:"<code>SaveFilePickerModule.h</code>",id:"savefilepickermoduleh",level:4},{value:"<code>SaveFilePickerModule.mm</code>",id:"savefilepickermodulemm",level:4}]},g="wrapper";function b(e){let{components:n,...t}=e;return(0,i.kt)(g,(0,l.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"savefilepickermoduleh"},(0,i.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModule.h")),(0,i.kt)("p",null,"Now, let's move to the module that will manage function calls from the JS world:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePicker.h"',title:'"ios/SaveFilePicker.h"'},'#import <React/RCTBridgeModule.h>\n\n/**\n * When using Swift classes in ObjC header, the class must have its\n * "forward declaration"\n * \n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations\n */\n@class SaveFilePickerModuleImpl;\n\n\n/**\n * Declare the ObjC interface for that native module class.\n * \n * It must extend NSObject (like every class in ObjC) and\n * implement RCTBridgeModule (like each RN native module).\n * \n * If the module emits events, it must extend RCTEventEmitter class.\n */\n@interface SaveFilePickerModule : NSObject<RCTBridgeModule>\n\n@end\n')),(0,i.kt)("p",null,"In the header file for ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," class we declare our class extending ",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject")," (as every class in ObjC) and implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTBridgeModule")," (as each RN iOS module class)."),(0,i.kt)("p",null,"Additionally, to use Swift ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl"),' class, we must do "forward-declaration" (check out Apple\'s Swift-ObjC interop ',(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations"},"dedicated docs section"),")."),(0,i.kt)("h4",{id:"savefilepickermodulemm"},(0,i.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModule.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},'#import "SaveFilePickerModule.h"\n\n/**\n * When using Swift classes in ObjC implementation, the classes must be imported\n * from generated Objective-C Interface Header\n *\n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Import-Code-Within-an-App-Target\n */\n#import "SaveFilePickerPackage-Swift.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "SaveFilePickerPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface SaveFilePickerModule () <NativeSaveFilePickerModuleSpec>\n@end\n#endif\n\n// Declare the ObjC implementation for that native module class\n@implementation SaveFilePickerModule\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(SaveFilePickerModule)\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeSaveFilePickerModuleSpecJSI>(params);\n}\n#endif\n\n@end\n')),(0,i.kt)("p",null,"This is the implementation file for ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," class."),(0,i.kt)("p",null,"Before declaring the implementation block, we have to import Swift-ObjC generated interface header (check out ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations"},"dedicated docs section"),"),\nand we have to implement code-generated spec protocol for new architecture (code between ",(0,i.kt)("inlineCode",{parentName:"p"},"#if RCT_NEW_ARCH_ENABLED")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif")," directives)."),(0,i.kt)("p",null,"After that, inside implementation block we have ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro invoked with ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," argument. This basically registers the module with provided name on iOS side, so that it's accessible in the JS world."),(0,i.kt)("p",null,"Also, for new architecture, it implements ",(0,i.kt)("inlineCode",{parentName:"p"},"- getTurboModule:")," method (from ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTTurboModule")," protocol).\nIf you won't implement that method, XCode will complain that the code-generated spec protocol methods are not implemented."),(0,i.kt)("p",null,"Let's combine module-implementation with module class"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},"//\n\n// highlight-start\n@interface SaveFilePickerModule () <SaveFilePickerModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n// highlight-end\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(SaveFilePickerModule)\n\n// highlight-start\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [SaveFilePickerModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return YES;\n}\n\n/**\n * If the module interacts with UIKit,\n * it can declare that its methods should be run on main queue\n */\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n// highlight-end\n\n//\n\n@end\n")),(0,i.kt)("p",null,"First, we declare private variable on ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModule")," for module-implementation which will be initialized in the ",(0,i.kt)("inlineCode",{parentName:"p"},"- init")," method.\nWe can use ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," Swift class, because it's imported from ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerPackage-Swift.h"),"."),(0,i.kt)("p",null,"We also declared private variables for callback and promise blocks, we will use them to communicate result back to the JS code."),(0,i.kt)("p",null,"Next, we override static method ",(0,i.kt)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup"),", which must be done whenever ",(0,i.kt)("inlineCode",{parentName:"p"},"- init")," method on the RN's wrapper class is overriden. "),(0,i.kt)("p",null,"As we will interact with the UIKit API, we will need to do it on the main queue.\nWe could just wrap UIKit code in ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch_async(dispatch_get_main_queue(), ^{ ... });"),",\nbut there's also an option to specify the ",(0,i.kt)("inlineCode",{parentName:"p"},"- methodQueue")," getter.\nIt's used to describe on which queue this module calls should be run.\nSo in our case, we will want to use the main queue - returning ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch_get_main_queue()")," from the getter will do the job."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"To learn more about dispatch queues in ObjC, you may visit Apple's ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html"},"dedicated guide"),".")),(0,i.kt)("p",null,"We still have 2 things to do - as you may noticed, XCode displayed a warning about ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleDelegate"),".\nThe module class is marked to be implementing the delegate protocol,\nthe module-implementation's delegate property is set to this module instance,\nbut we still need to implement delegate's methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},'//\n\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n\n//\n\n/**\n * If the module interacts with UIKit,\n * it can declare that its methods should be run on main queue\n */\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n\n// highlight-start\n- (void)onSuccess\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(YES), @"cancelled": @(NO) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(YES));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onCancel\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(YES) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(NO));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onError:(NSError *)error\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(NO), @"error": @{ @"code": @(error.code), @"message": error.localizedDescription } }]);\n    } else if (rejectBlock != nil) {\n        rejectBlock([NSString stringWithFormat:@"%@", @(error.code)], error.localizedDescription, error);\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n// highlight-end\n\n@end\n')),(0,i.kt)("p",null,"In the delegate's methods, we are invoking callback/promise response blocks, with the result arguments.\nAs a cleanup, we are setting response blocks to ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),", so that these are not called second time."),(0,i.kt)("p",null,"The last thing is to export the methods to the JS layer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/SaveFilePickerModule.mm"',title:'"ios/SaveFilePickerModule.mm"'},'//\n\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n\n//\n\n/**\n * If the module interacts with UIKit,\n * it can declare that its methods should be run on main queue\n */\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n\n// highlight-start\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_METHOD(saveFileWithCallback : (NSString *)filename\n                              callback : (RCTResponseSenderBlock)callback)\n{\n    callbackBlock = callback;\n    [moduleImpl saveFileWithFilename:filename];\n}\n\nRCT_EXPORT_METHOD(saveFileWithPromise : (NSString *)filename\n                              resolve : (RCTPromiseResolveBlock)resolve\n                               reject : (RCTPromiseRejectBlock)reject)\n{\n    resolveBlock = resolve;\n    rejectBlock = reject;\n    [moduleImpl saveFileWithFilename:filename];\n}\n// highlight-end\n\n- (void)onSuccess\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(YES), @"cancelled": @(NO) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(YES));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onCancel\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(YES) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(NO));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onError:(NSError *)error\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(NO), @"error": @{ @"code": @(error.code), @"message": error.localizedDescription } }]);\n    } else if (rejectBlock != nil) {\n        rejectBlock([NSString stringWithFormat:@"%@", @(error.code)], error.localizedDescription, error);\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n@end\n')),(0,i.kt)("p",null,"Inside exported methods, we are doing 2 things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"we save callback/promise response blocks"),(0,i.kt)("li",{parentName:"ul"},"we use module-implementation to show the picker")),(0,i.kt)(r.ZP,{filename:"SaveFilePickerModule.mm",language:"objc",mdxType:"CompleteFile"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#import "SaveFilePickerModule.h"\n\n/**\n * When using Swift classes in ObjC implementation, the classes must be imported\n * from generated Objective-C Interface Header\n *\n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Import-Code-Within-an-App-Target\n */\n#import "SaveFilePickerPackage-Swift.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "SaveFilePickerPackage.h"\n\n// Each turbo module extends codegenerated spec class\n@interface SaveFilePickerModule () <NativeSaveFilePickerModuleSpec>\n@end\n#endif\n\n@interface SaveFilePickerModule () <SaveFilePickerModuleDelegate>\n@end\n\n// Declare the ObjC implementation for that native module class\n@implementation SaveFilePickerModule {\n    SaveFilePickerModuleImpl *moduleImpl;\n    RCTResponseSenderBlock callbackBlock;\n    RCTPromiseResolveBlock resolveBlock;\n    RCTPromiseRejectBlock rejectBlock;\n}\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(SaveFilePickerModule)\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [SaveFilePickerModuleImpl new];\n        moduleImpl.delegate = self;\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return YES;\n}\n\n/**\n* If the module interacts with UIKit,\n* it can declare that its methods should be run on main queue\n*/\n- (dispatch_queue_t)methodQueue {\n    return dispatch_get_main_queue();\n}\n\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_METHOD(saveFileWithCallback : (NSString *)filename\n                              callback : (RCTResponseSenderBlock)callback)\n{\n    callbackBlock = callback;\n    [moduleImpl saveFileWithFilename:filename];\n}\n\nRCT_EXPORT_METHOD(saveFileWithPromise : (NSString *)filename\n                              resolve : (RCTPromiseResolveBlock)resolve\n                              reject : (RCTPromiseRejectBlock)reject)\n{\n    resolveBlock = resolve;\n    rejectBlock = reject;\n    [moduleImpl saveFileWithFilename:filename];\n}\n\n- (void)onSuccess\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(YES), @"cancelled": @(NO) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(YES));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onCancel\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(YES) }]);\n    } else if (resolveBlock != nil) {\n        resolveBlock(@(NO));\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n- (void)onError:(NSError *)error\n{\n    if (callbackBlock != nil) {\n        callbackBlock(@[@{ @"success": @(NO), @"cancelled": @(NO), @"error": @{ @"code": @(error.code), @"message": error.localizedDescription } }]);\n    } else if (rejectBlock != nil) {\n        rejectBlock([NSString stringWithFormat:@"%@", @(error.code)], error.localizedDescription, error);\n    }\n    callbackBlock = nil;\n    resolveBlock = nil;\n    rejectBlock = nil;\n}\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeSaveFilePickerModuleSpecJSI>(params);\n}\n#endif\n\n@end\n'))))}b.isMDXComponent=!0;var S=t(5403);const C={toc:[{value:"<code>SaveFilePickerModuleImpl.swift</code>",id:"savefilepickermoduleimplswift",level:4}]},w="wrapper";function N(e){let{components:n,...t}=e;return(0,i.kt)(w,(0,l.Z)({},C,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"savefilepickermoduleimplswift"},(0,i.kt)("inlineCode",{parentName:"h4"},"SaveFilePickerModuleImpl.swift")),(0,i.kt)("p",null,"Let's start by creating a module-implementation that will be used by our module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/SaveFilePickerModuleImpl.swift"',title:'"ios/SaveFilePickerModuleImpl.swift"'},'import UIKit\n\n@objc(SaveFilePickerModuleDelegate)\npublic protocol SaveFilePickerModuleDelegate: AnyObject {\n    func onCancel()\n    func onError(_ error: Error)\n    func onSuccess()\n}\n\n/**\n * Native module\'s shared implementation\n */\n@objc(SaveFilePickerModuleImpl)\npublic class SaveFilePickerModuleImpl : NSObject {\n    @objc public weak var delegate: SaveFilePickerModuleDelegate? = nil\n    \n    static let INVALID_PATH_ERROR_MESSAGE = "Invalid path"\n    static let NO_VIEW_CONTROLLER_ERROR_MESSAGE = "No viewcontroller"\n\n    @objc public func saveFileWithFilename(_ filename: String) {\n        \n    }\n}\n')),(0,i.kt)("p",null,"Here, we declare ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleImpl")," class together with ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleDelegate")," protocol."),(0,i.kt)(S.ZP,{mdxType:"ExportingObjCInfo"}),(0,i.kt)("p",null,"The class will have weak delegate property and one method. For error handling, we also declare 2 static error messages, that will be used later."),(0,i.kt)("p",null,"For saving file functionality we will use ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidocumentpickerviewcontroller"},(0,i.kt)("inlineCode",{parentName:"a"},"UIDocumentPickerViewController")),",\nmore specifically its ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidocumentpickerviewcontroller/3566733-init"},(0,i.kt)("inlineCode",{parentName:"a"},"init(forOpeningContentTypes:asCopy:)"))," initializer."),(0,i.kt)("p",null,"And to consume the result from the picker, the module-implementation class needs to implement ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/uikit/uidocumentpickerdelegate"},(0,i.kt)("inlineCode",{parentName:"a"},"UIDocumentPickerDelegate")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/SaveFilePickerModuleImpl.swift"',title:'"ios/SaveFilePickerModuleImpl.swift"'},'/**\n * Native module\'s shared implementation\n */\n@objc(SaveFilePickerModuleImpl)\npublic class SaveFilePickerModuleImpl : NSObject {\n    @objc public weak var delegate: SaveFilePickerModuleDelegate? = nil\n    \n    static let INVALID_PATH_ERROR_MESSAGE = "Invalid path"\n    static let NO_VIEW_CONTROLLER_ERROR_MESSAGE = "No viewcontroller"\n\n    @objc public func saveFileWithFilename(_ filename: String) {\n// highlight-start\n        let filenameComponents = filename.components(separatedBy: ".")\n        guard let url = Bundle.main.url(forResource: filenameComponents[0], withExtension: filenameComponents[1]) else {\n            let error = SaveFilePickerError.InvalidPath(SaveFilePickerModuleImpl.INVALID_PATH_ERROR_MESSAGE)\n            delegate?.onError(error)\n            return\n        }\n\n        guard let presentedViewController = RCTPresentedViewController() else {\n            let error = SaveFilePickerError.NoViewController(SaveFilePickerModuleImpl.NO_VIEW_CONTROLLER_ERROR_MESSAGE)\n            delegate?.onError(error)\n            return\n        }\n\n        let documentPicker = self.createDocumentPicker(with: url)\n        documentPicker.delegate = self\n        presentedViewController.present(documentPicker, animated: true)\n// highlight-end\n    }\n    \n// highlight-start\n    private func createDocumentPicker(with url: URL) -> UIDocumentPickerViewController {\n        if #available(iOS 14.0, *) {\n            return UIDocumentPickerViewController(forExporting: [url], asCopy: true)\n        }\n        return UIDocumentPickerViewController(url: url, in: .exportToService)\n    }\n// highlight-end\n}\n\n// highlight-start\nextension SaveFilePickerModuleImpl : UIDocumentPickerDelegate {\n    public func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {\n        delegate?.onSuccess()\n        controller.delegate = nil\n    }\n    \n    public func documentPickerWasCancelled(_ controller: UIDocumentPickerViewController) {\n        delegate?.onCancel()\n        controller.delegate = nil\n    }\n}\n// highlight-end\n\n// highlight-start\nenum SaveFilePickerError: Error {\n    case InvalidPath(String)\n    case NoViewController(String)\n}\n// highlight-end\n')),(0,i.kt)("p",null,"First take a look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"UIDocumentPickerDelegate")," implementation - we are implementing two methods, one is returning the urls where the file was saved and the other is called when user cancelled the picker.\nIn those methods, we have to call ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerModuleDelegate")," delegate to communicate success or cancellation.\nWhen it's done, the picker's delegate ",(0,i.kt)("inlineCode",{parentName:"p"},"controller.delegate")," needs to be cleared."),(0,i.kt)("p",null,"Now we can start implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"saveFileWithFilename")," method.\nWe begin with getting the URL for the file from assets based on the ",(0,i.kt)("inlineCode",{parentName:"p"},"filename")," argument.\nIf it cannot be obtained, we have to early-return and communicate to the delegate, that there's no such file with that path.\nTo construct the Error struct we are using custom enum ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerError")," defined at the bottom of the file."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"For more on custom errors in Swift, you may visit ",(0,i.kt)("a",{parentName:"p",href:"https://www.advancedswift.com/custom-errors-in-swift/"},"this article"),".")),(0,i.kt)("p",null,"Next step is to take currently presented view controller - will use it to modally display the file picker.\nAs with the url, we also have to do error handling for the case when there's no presented view controller (~0.001% chance, but we should still do it)."),(0,i.kt)("p",null,"Finally, we create the picker and present it modally. To create the picker we are using ",(0,i.kt)("inlineCode",{parentName:"p"},"createDocumentPicker")," helper.\nIt's because the initializer we want to use is available from iOS 14, but our package declares support down to iOS 13.\nTo handle it, we are using availability check (",(0,i.kt)("inlineCode",{parentName:"p"},"if #available"),") to use new initilaizer for iOS 14+ and fall back to old initializer for iOS 13."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"For more on availability API, you can visit Apple ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/marking-api-availability-in-objective-c#Check-Availability"},"dedicated docs's section"),".")),(0,i.kt)("p",null,"When the picker is initialized, we have to set its delegate property to this module instance and present it."))}N.isMDXComponent=!0;const P={toc:[]},B="wrapper";function M(e){let{components:n,...t}=e;return(0,i.kt)(B,(0,l.Z)({},P,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(N,{mdxType:"IosSwiftModuleImpl"}),(0,i.kt)(b,{mdxType:"IosSwiftModule"}))}M.isMDXComponent=!0;const I={sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},F=void 0,R={unversionedId:"guides/save-file-picker-module/ios-impl",id:"guides/save-file-picker-module/ios-impl",title:"iOS implementation",description:"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:",source:"@site/docs/guides/save-file-picker-module/ios-impl.mdx",sourceDirName:"guides/save-file-picker-module",slug:"/guides/save-file-picker-module/ios-impl",permalink:"/rnbridgingtutorial/docs/guides/save-file-picker-module/ios-impl",draft:!1,editUrl:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/docs/docs/guides/save-file-picker-module/ios-impl.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},sidebar:"tutorialSidebar",previous:{title:"JS specification",permalink:"/rnbridgingtutorial/docs/guides/save-file-picker-module/js-spec"},next:{title:"Android implementation",permalink:"/rnbridgingtutorial/docs/guides/save-file-picker-module/android-impl"}},T={},E=[],_={toc:E},O="wrapper";function j(e){let{components:n,...t}=e;return(0,i.kt)(O,(0,l.Z)({},_,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"xed ios\n")),(0,i.kt)("p",null,"When workspace is opened, locate ",(0,i.kt)("inlineCode",{parentName:"p"},"Pods")," project and expand it. Search for ",(0,i.kt)("inlineCode",{parentName:"p"},"Development Pods")," and find ",(0,i.kt)("inlineCode",{parentName:"p"},"SaveFilePickerPackage")," inside. When it's expanded, it will show all files that we created under ",(0,i.kt)("inlineCode",{parentName:"p"},"save-file-package/ios")," directory."),(0,i.kt)(o.Z,{groupId:"ios_lang",mdxType:"Tabs"},(0,i.kt)(a.Z,{value:"swift",label:"ObjC++ & Swift",mdxType:"TabItem"},(0,i.kt)(M,{mdxType:"IosSwiftImpl"})),(0,i.kt)(a.Z,{value:"objc",label:"ObjC++ only",mdxType:"TabItem"},(0,i.kt)(v,{mdxType:"IosObjCImpl"}))),(0,i.kt)("p",null,"You can check training repo for ObjC & Swift implementation ",(0,i.kt)("a",{parentName:"p",href:"https://r.mtdv.me/FtXpuO4X9f"},"here")," and ObjC-only implementation ",(0,i.kt)("a",{parentName:"p",href:"https://r.mtdv.me/FtXpuO4X9f"},"here"),"."),(0,i.kt)("p",null,"That's iOS part, now let's go to Android!"))}j.isMDXComponent=!0}}]);