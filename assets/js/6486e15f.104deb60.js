"use strict";(self.webpackChunkbridging_tutorial_website=self.webpackChunkbridging_tutorial_website||[]).push([[1062],{5162:(e,n,t)=>{t.d(n,{Z:()=>l});var o=t(7294),i=t(6010);const a={tabItem:"tabItem_Ymn6"};function l(e){let{children:n,hidden:t,className:l}=e;return o.createElement("div",{role:"tabpanel",className:(0,i.Z)(a.tabItem,l),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>C});var o=t(7462),i=t(7294),a=t(6010),l=t(2466),p=t(6550),r=t(1980),d=t(7392),m=t(12);function u(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:o,default:i}}=e;return{value:n,label:t,attributes:o,default:i}}))}function s(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??u(t);return function(e){const n=(0,d.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function c(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const o=(0,p.k6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,r._X)(a),(0,i.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(o.location.search);n.set(a,e),o.replace({...o.location,search:n.toString()})}),[a,o])]}function h(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,a=s(e),[l,p]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!c({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=t.find((e=>e.default))??t[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:a}))),[r,d]=f({queryString:t,groupId:o}),[u,h]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[o,a]=(0,m.Nk)(t);return[o,(0,i.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:o}),b=(()=>{const e=r??u;return c({value:e,tabValues:a})?e:null})();(0,i.useLayoutEffect)((()=>{b&&p(b)}),[b]);return{selectedValue:l,selectValue:(0,i.useCallback)((e=>{if(!c({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);p(e),d(e),h(e)}),[d,h,a]),tabValues:a}}var b=t(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function I(e){let{className:n,block:t,selectedValue:p,selectValue:r,tabValues:d}=e;const m=[],{blockElementScrollPositionUntilNextRender:u}=(0,l.o5)(),s=e=>{const n=e.currentTarget,t=m.indexOf(n),o=d[t].value;o!==p&&(u(n),r(o))},c=e=>{let n=null;switch(e.key){case"Enter":s(e);break;case"ArrowRight":{const t=m.indexOf(e.currentTarget)+1;n=m[t]??m[0];break}case"ArrowLeft":{const t=m.indexOf(e.currentTarget)-1;n=m[t]??m[m.length-1];break}}n?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":t},n)},d.map((e=>{let{value:n,label:t,attributes:l}=e;return i.createElement("li",(0,o.Z)({role:"tab",tabIndex:p===n?0:-1,"aria-selected":p===n,key:n,ref:e=>m.push(e),onKeyDown:c,onClick:s},l,{className:(0,a.Z)("tabs__item",g.tabItem,l?.className,{"tabs__item--active":p===n})}),t??n)})))}function k(e){let{lazy:n,children:t,selectedValue:o}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===o));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==o}))))}function N(e){const n=h(e);return i.createElement("div",{className:(0,a.Z)("tabs-container",g.tabList)},i.createElement(I,(0,o.Z)({},e,n)),i.createElement(k,(0,o.Z)({},e,n)))}function C(e){const n=(0,b.Z)();return i.createElement(N,(0,o.Z)({key:String(n)},e))}},6162:(e,n,t)=>{t.d(n,{ZP:()=>r});var o=t(7462),i=(t(7294),t(3905)),a=t(814);const l={toc:[]},p="wrapper";function r(e){let{components:n,...t}=e;return(0,i.kt)(p,(0,o.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Complete ",(0,i.kt)("code",null,t.filename)," file"),(0,i.kt)("div",null,(0,i.kt)(a.Z,{language:t.language,mdxType:"CodeBlock"},t.children))))}r.isMDXComponent=!0},5403:(e,n,t)=>{t.d(n,{ZP:()=>p});var o=t(7462),i=(t(7294),t(3905));const a={toc:[]},l="wrapper";function p(e){let{components:n,...t}=e;return(0,i.kt)(l,(0,o.Z)({},a,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"To make Swift elements accessible to ObjC world, we have to do 4 things:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"make class extending ",(0,i.kt)("inlineCode",{parentName:"li"},"NSObject")),(0,i.kt)("li",{parentName:"ul"},"mark class and its methods (at least those methods that are meant to be exposed) as public"),(0,i.kt)("li",{parentName:"ul"},"mark class with ",(0,i.kt)("inlineCode",{parentName:"li"},"@objc(exported-objc-name)")," decorator"),(0,i.kt)("li",{parentName:"ul"},"mark exposed methods with ",(0,i.kt)("inlineCode",{parentName:"li"},"@objc")," decorator"))))}p.isMDXComponent=!0},4926:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>E,contentTitle:()=>O,default:()=>j,frontMatter:()=>w,metadata:()=>_,toc:()=>R});var o=t(7462),i=(t(7294),t(3905)),a=t(4866),l=t(5162),p=t(6162);const r={toc:[{value:"<code>AppInfoModule.h</code>",id:"appinfomoduleh",level:4},{value:"<code>AppInfoModule.mm</code>",id:"appinfomodulemm",level:4}]},d="wrapper";function m(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,o.Z)({},r,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"appinfomoduleh"},(0,i.kt)("inlineCode",{parentName:"h4"},"AppInfoModule.h")),(0,i.kt)("p",null,"Now, let's move to the module that will manage function calls from the JS world:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.h"',title:'"ios/AppInfoModule.h"'},"#import <React/RCTBridgeModule.h>\n\n/**\n * Declare the ObjC interface for that native module class.\n * \n * It must extend NSObject (like every class in ObjC) and\n * implement RCTBridgeModule (like each RN native module).\n */\n@interface AppInfoModule : NSObject<RCTBridgeModule>\n\n@end\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," class extends base ",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject")," class (each class in ObjC needs to extend ",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject"),") and implements ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTBridgeModule")," protocol (each RN iOS module needs to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTBridgeModule")," protocol)."),(0,i.kt)("h4",{id:"appinfomodulemm"},(0,i.kt)("inlineCode",{parentName:"h4"},"AppInfoModule.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.mm"',title:'"ios/AppInfoModule.mm"'},'#import "AppInfoModule.h"\n\n#import "AppInfoModuleImpl.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "AppInfoPackage.h"\n\n/**\n * Each turbo module implements codegenerated spec protocol\n */\n@interface AppInfoModule () <NativeAppInfoModuleSpec>\n@end\n#endif\n\n/**\n * Declare the ObjC implementation for that native module class\n */\n@implementation AppInfoModule\n\n/**\n * Return the name of the module - it should match the name provided in JS specification\n */\nRCT_EXPORT_MODULE(AppInfoModule)\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {\n    return std::make_shared<facebook::react::NativeAppInfoModuleSpecJSI>(params);\n}\n#endif\n\n@end\n')),(0,i.kt)("p",null,"This is the implementation file for ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," class."),(0,i.kt)("p",null,"Before declaring the implementation block, we have to import header file for ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl")," module-implementation class,\nand we have to implement code-generated spec protocol for new architecture (code between ",(0,i.kt)("inlineCode",{parentName:"p"},"#if RCT_NEW_ARCH_ENABLED")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif")," directives)."),(0,i.kt)("p",null,"After that, inside implementation block we have ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro invoked with ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," argument. This basically registers the module with provided name on iOS side, so that it's accessible in the JS world."),(0,i.kt)("p",null,"Also, for new architecture, it implements ",(0,i.kt)("inlineCode",{parentName:"p"},"- getTurboModule:")," method (from ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTTurboModule")," protocol).\nIf you won't implement that method, XCode will complain that the code-generated spec protocol methods are not implemented."),(0,i.kt)("p",null,"Let's combine module-implementation with RN's wrapper class"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.mm"',title:'"ios/AppInfoModule.mm"'},"//\n\n// highlight-start\n/**\n * Declare the ObjC implementation for that native module class\n */\n@implementation AppInfoModule {\n    AppInfoModuleImpl *moduleImpl;\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [AppInfoModuleImpl new];\n    }\n    return self;\n}\n// highlight-end\n\n/**\n * Return the name of the module - it should match the name provided in JS specification\n */\nRCT_EXPORT_MODULE(AppInfoModule)\n\n// highlight-start\n/**\n * Declare if module should be initialized on the main queue\n */\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n// highlight-end\n\n//\n\n@end\n")),(0,i.kt)("p",null,"First, we declare private variable on ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," which will be initialized in the ",(0,i.kt)("inlineCode",{parentName:"p"},"- init")," method. We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl")," ObjC class, because it's imported from ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl.h"),"."),(0,i.kt)("p",null,"Next, we override static method ",(0,i.kt)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup"),", which must be done whenever ",(0,i.kt)("inlineCode",{parentName:"p"},"- init")," method on the RN's wrapper class is overriden. "),(0,i.kt)("p",null,"Finally, we can register exported methods with ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD")," macro and return value from module-implementation class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.mm"',title:'"ios/AppInfoModule.mm"'},"//\n\n/**\n * Declare the ObjC implementation for that native module class\n */\n@implementation AppInfoModule {\n    AppInfoModuleImpl *moduleImpl;\n}\n\n// highlight-start\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBuildNumber)\n{\n    return [moduleImpl getAppBuildNumber];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBundleId)\n{\n    return [moduleImpl getAppBundleId];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppVersion)\n{\n    return [moduleImpl getAppVersion];\n}\n// highlight-end\n\n//\n\n@end\n")),(0,i.kt)(p.ZP,{filename:"AppInfoModule.mm",language:"objc",mdxType:"CompleteFile"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#import "AppInfoModule.h"\n\n#import "AppInfoModuleImpl.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n* Import header file with codegenerated protocols based on the JS specification\n*\n* The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n*/\n#import "AppInfoPackage.h"\n\n// Each turbo module implements codegenerated spec protocol\n@interface AppInfoModule () <NativeAppInfoModuleSpec>\n@end\n#endif\n\n// Declare the ObjC implementation for that native module class\n@implementation AppInfoModule {\n    AppInfoModuleImpl *moduleImpl;\n}\n\n// Return the name of the module - it should match the name provided in JS specification\nRCT_EXPORT_MODULE(AppInfoModule)\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [AppInfoModuleImpl new];\n    }\n    return self;\n}\n\n// Declare if module should be initialized on the main queue\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBuildNumber)\n{\n    return [moduleImpl getAppBuildNumber];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBundleId)\n{\n    return [moduleImpl getAppBundleId];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppVersion)\n{\n    return [moduleImpl getAppVersion];\n}\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:\n    (const facebook::react::ObjCTurboModule::InitParams &)params\n{\n    return std::make_shared<facebook::react::NativeAppInfoModuleSpecJSI>(params);\n}\n#endif\n\n@end\n'))))}m.isMDXComponent=!0;const u={toc:[{value:"<code>AppInfoModuleImpl.h</code>",id:"appinfomoduleimplh",level:4},{value:"<code>AppInfoModuleImpl.mm</code>",id:"appinfomoduleimplmm",level:4}]},s="wrapper";function c(e){let{components:n,...t}=e;return(0,i.kt)(s,(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"appinfomoduleimplh"},(0,i.kt)("inlineCode",{parentName:"h4"},"AppInfoModuleImpl.h")),(0,i.kt)("p",null,"Let's start by creating a module-implementation that will be used by our module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModuleImpl.h"',title:'"ios/AppInfoModuleImpl.h"'},"#import <Foundation/Foundation.h>\n\n@interface AppInfoModuleImpl : NSObject\n\n- (NSString *)getAppBuildNumber;\n- (NSString *)getAppBundleId;\n- (NSString *)getAppVersion;\n\n@end\n")),(0,i.kt)("h4",{id:"appinfomoduleimplmm"},(0,i.kt)("inlineCode",{parentName:"h4"},"AppInfoModuleImpl.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModuleImpl.mm"',title:'"ios/AppInfoModuleImpl.mm"'},'#import "AppInfoModuleImpl.h"\n\n/**\n * Native module\'s shared implementation\n */\n@implementation AppInfoModuleImpl\n\n- (NSString *)getAppBuildNumber\n{\n    return [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"];\n}\n\n- (NSString *)getAppBundleId\n{\n    return [[NSBundle mainBundle] bundleIdentifier];\n}\n\n- (NSString *)getAppVersion\n{\n    return [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"];\n}\n\n@end\n')),(0,i.kt)("p",null,"Here, we declare ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl")," class, which has 3 synchronous methods."),(0,i.kt)("p",null,"Methods in the class are using ",(0,i.kt)("inlineCode",{parentName:"p"},"NSBundle")," class, for the reference, check out Apple's ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/nsbundle?language=objc"},"dedicated docs section"),"."),(0,i.kt)("p",null,"We will use main ",(0,i.kt)("inlineCode",{parentName:"p"},"NSBundle")," instance to ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/nsbundle#1652578"},"retrieve some information about the app"),"."),(0,i.kt)("p",null,"In case of ",(0,i.kt)("inlineCode",{parentName:"p"},"- getAppBundleId")," method, we will use ",(0,i.kt)("inlineCode",{parentName:"p"},"bundleIdentifier")," property, for other methods we use ",(0,i.kt)("em",{parentName:"p"},"generic")," ",(0,i.kt)("inlineCode",{parentName:"p"},"- objectForInfoDictionaryKey:")," method, where the argument is a key from ",(0,i.kt)("inlineCode",{parentName:"p"},"Info.plist"),".\nFor possible ",(0,i.kt)("inlineCode",{parentName:"p"},"Info.plist")," keys, visit ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html"},'"About Info.plist keys and values"'),"."))}c.isMDXComponent=!0;const f={toc:[]},h="wrapper";function b(e){let{components:n,...t}=e;return(0,i.kt)(h,(0,o.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(c,{mdxType:"IosObjCModuleImpl"}),(0,i.kt)(m,{mdxType:"IosObjCModule"}))}b.isMDXComponent=!0;const g={toc:[{value:"<code>AppInfoModule.h</code>",id:"appinfomoduleh",level:4},{value:"<code>AppInfoModule.mm</code>",id:"appinfomodulemm",level:4}]},I="wrapper";function k(e){let{components:n,...t}=e;return(0,i.kt)(I,(0,o.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"appinfomoduleh"},(0,i.kt)("inlineCode",{parentName:"h4"},"AppInfoModule.h")),(0,i.kt)("p",null,"Now, let's move to the module that will manage function calls from the JS world:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.h"',title:'"ios/AppInfoModule.h"'},'#import <React/RCTBridgeModule.h>\n\n/**\n * When using Swift classes in ObjC header, the class must have its\n * "forward declaration"\n * \n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations\n */\n@class AppInfoModuleImpl;\n\n/**\n * Declare the ObjC interface for that native module class.\n * \n * It must extend NSObject (like every class in ObjC) and\n * implement RCTBridgeModule (like each RN native module).\n */\n@interface AppInfoModule : NSObject<RCTBridgeModule>\n\n@end\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," class extends base ",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject")," class (each class in ObjC needs to extend ",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject"),") and implements ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTBridgeModule")," protocol (each RN iOS module needs to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTBridgeModule")," protocol)."),(0,i.kt)("p",null,"Additionally, to use Swift ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl"),' class, we must do "forward-declaration" (check out Apple\'s Swift-ObjC interop ',(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations"},"dedicated docs section"),")."),(0,i.kt)("h4",{id:"appinfomodulemm"},(0,i.kt)("inlineCode",{parentName:"h4"},"AppInfoModule.mm")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.mm"',title:'"ios/AppInfoModule.mm"'},'#import "AppInfoModule.h"\n\n/**\n * When using Swift classes in ObjC implementation, the classes must be imported\n * from generated Objective-C Interface Header\n *\n * @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Import-Code-Within-an-App-Target\n */\n#import "AppInfoPackage-Swift.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n * Import header file with codegenerated protocols based on the JS specification\n *\n * The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n */\n#import "AppInfoPackage.h"\n\n/**\n * Each turbo module implements codegenerated spec protocol\n */\n@interface AppInfoModule () <NativeAppInfoModuleSpec>\n@end\n#endif\n\n/**\n * Declare the ObjC implementation for that native module class\n */\n@implementation AppInfoModule\n\n/**\n * Return the name of the module - it should match the name provided in JS specification\n */\nRCT_EXPORT_MODULE(AppInfoModule)\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {\n    return std::make_shared<facebook::react::NativeAppInfoModuleSpecJSI>(params);\n}\n#endif\n\n@end\n')),(0,i.kt)("p",null,"This is the implementation file for ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," class."),(0,i.kt)("p",null,"Before declaring the implementation block, we have to import Swift-ObjC generated interface header (check out ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Include-Swift-Classes-in-Objective-C-Headers-Using-Forward-Declarations"},"dedicated docs section"),"),\nand we have to implement code-generated spec protocol for new architecture (code between ",(0,i.kt)("inlineCode",{parentName:"p"},"#if RCT_NEW_ARCH_ENABLED")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif")," directives)."),(0,i.kt)("p",null,"After that, inside implementation block we have ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro invoked with ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," argument. This basically registers the module with provided name on iOS side, so that it's accessible in the JS world."),(0,i.kt)("p",null,"Also, for new architecture, it implements ",(0,i.kt)("inlineCode",{parentName:"p"},"- getTurboModule:")," method (from ",(0,i.kt)("inlineCode",{parentName:"p"},"RCTTurboModule")," protocol).\nIf you won't implement that method, XCode will complain that the code-generated spec protocol methods are not implemented."),(0,i.kt)("p",null,"Let's combine module-implementation with module class"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.mm"',title:'"ios/AppInfoModule.mm"'},"//\n\n// highlight-start\n/**\n * Declare the ObjC implementation for that native module class\n */\n@implementation AppInfoModule {\n    AppInfoModuleImpl *moduleImpl;\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [AppInfoModuleImpl new];\n    }\n    return self;\n}\n// highlight-end\n\n/**\n * Return the name of the module - it should match the name provided in JS specification\n */\nRCT_EXPORT_MODULE(AppInfoModule)\n\n// highlight-start\n/**\n * Declare if module should be initialized on the main queue\n */\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n// highlight-end\n\n//\n\n@end\n")),(0,i.kt)("p",null,"First, we declare private variable on ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModule")," which will be initialized in the ",(0,i.kt)("inlineCode",{parentName:"p"},"- init")," method. We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl")," Swift class, because it's imported from ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoPackage-Swift.h"),"."),(0,i.kt)("p",null,"Next, we override static method ",(0,i.kt)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup"),", which must be done whenever ",(0,i.kt)("inlineCode",{parentName:"p"},"- init")," method on the RN's wrapper class is overriden. "),(0,i.kt)("p",null,"Finally, we can register exported methods with ",(0,i.kt)("inlineCode",{parentName:"p"},"RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD")," macro and return value from module-implementation class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc",metastring:'title="ios/AppInfoModule.mm"',title:'"ios/AppInfoModule.mm"'},"//\n\n/**\n * Declare the ObjC implementation for that native module class\n */\n@implementation AppInfoModule {\n    AppInfoModuleImpl *moduleImpl;\n}\n\n// highlight-start\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBuildNumber)\n{\n    return [moduleImpl getAppBuildNumber];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBundleId)\n{\n    return [moduleImpl getAppBundleId];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppVersion)\n{\n    return [moduleImpl getAppVersion];\n}\n// highlight-end\n\n//\n\n@end\n")),(0,i.kt)(p.ZP,{filename:"AppInfoModule.mm",language:"objc",mdxType:"CompleteFile"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#import "AppInfoModule.h"\n\n/**\n* When using Swift classes in ObjC implementation, the classes must be imported\n* from generated Objective-C Interface Header\n*\n* @see https://developer.apple.com/documentation/swift/importing-swift-into-objective-c#Import-Code-Within-an-App-Target\n*/\n#import "AppInfoPackage-Swift.h"\n\n#if RCT_NEW_ARCH_ENABLED\n/**\n* Import header file with codegenerated protocols based on the JS specification\n*\n* The name of the header matches the name provided in codegenConfig\'s `name` field in package.json\n*/\n#import "AppInfoPackage.h"\n\n/**\n* Each turbo module implements codegenerated spec protocol\n*/\n@interface AppInfoModule () <NativeAppInfoModuleSpec>\n@end\n#endif\n\n/**\n* Declare the ObjC implementation for that native module class\n*/\n@implementation AppInfoModule {\n    AppInfoModuleImpl *moduleImpl;\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        moduleImpl = [AppInfoModuleImpl new];\n    }\n    return self;\n}\n\n/**\n* Return the name of the module - it should match the name provided in JS specification\n*/\nRCT_EXPORT_MODULE(AppInfoModule)\n\n/**\n* Declare if module should be initialized on the main queue\n*/\n+ (BOOL)requiresMainQueueSetup\n{\n    return NO;\n}\n\n// Exported methods are overriden - based on the spec class\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBuildNumber)\n{\n    return [moduleImpl getAppBuildNumber];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppBundleId)\n{\n    return [moduleImpl getAppBundleId];\n}\n\nRCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSString *, getAppVersion)\n{\n    return [moduleImpl getAppVersion];\n}\n\n#if RCT_NEW_ARCH_ENABLED\n// Implement RCTTurboModule protocol\n- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {\n    return std::make_shared<facebook::react::NativeAppInfoModuleSpecJSI>(params);\n}\n#endif\n\n@end\n'))))}k.isMDXComponent=!0;var N=t(5403);const C={toc:[{value:"<code>AppInfoModuleImpl.swift</code>",id:"appinfomoduleimplswift",level:4}]},M="wrapper";function A(e){let{components:n,...t}=e;return(0,i.kt)(M,(0,o.Z)({},C,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"appinfomoduleimplswift"},(0,i.kt)("inlineCode",{parentName:"h4"},"AppInfoModuleImpl.swift")),(0,i.kt)("p",null,"Let's start by creating a module-implementation that will be used by our module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ios/AppInfoModuleImpl.swift"',title:'"ios/AppInfoModuleImpl.swift"'},'import Foundation\n\n@objc(AppInfoModuleImpl)\npublic class AppInfoModuleImpl : NSObject {\n    @objc public func getAppBuildNumber() -> String {\n        return Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") as! String\n    }\n\n    @objc public func getAppBundleId() -> String {\n        return Bundle.main.bundleIdentifier!\n    }\n\n    @objc public func getAppVersion() -> String {\n        return Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as! String\n    }\n}\n')),(0,i.kt)("p",null,"Here, we declare ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoModuleImpl")," class, which has 3 synchronous methods."),(0,i.kt)(N.ZP,{mdxType:"ExportingObjCInfo"}),(0,i.kt)("p",null,"Methods in the class are using ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle")," class, for the reference, check out Apple's ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/bundle"},"dedicated docs section"),"."),(0,i.kt)("p",null,"We will use main ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle")," instance to ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/foundation/bundle#1652578"},"retrieve some information about the app"),"."),(0,i.kt)("p",null,"In case of ",(0,i.kt)("inlineCode",{parentName:"p"},"getAppBundleId")," method, we will use ",(0,i.kt)("inlineCode",{parentName:"p"},"bundleIdentifier")," property, for other methods we use ",(0,i.kt)("em",{parentName:"p"},"generic")," ",(0,i.kt)("inlineCode",{parentName:"p"},"object(forInfoDictionaryKey:)")," method, where the argument is a key from ",(0,i.kt)("inlineCode",{parentName:"p"},"Info.plist"),".\nFor possible ",(0,i.kt)("inlineCode",{parentName:"p"},"Info.plist")," keys, visit ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html"},'"About Info.plist keys and values"'),"."))}A.isMDXComponent=!0;const T={toc:[]},S="wrapper";function v(e){let{components:n,...t}=e;return(0,i.kt)(S,(0,o.Z)({},T,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(A,{mdxType:"IosSwiftModuleImpl"}),(0,i.kt)(k,{mdxType:"IosSwiftModule"}))}v.isMDXComponent=!0;const w={sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},O=void 0,_={unversionedId:"guides/app-info-module/ios-impl",id:"guides/app-info-module/ios-impl",title:"iOS implementation",description:"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:",source:"@site/docs/guides/app-info-module/ios-impl.mdx",sourceDirName:"guides/app-info-module",slug:"/guides/app-info-module/ios-impl",permalink:"/rnbridgingtutorial/docs/guides/app-info-module/ios-impl",draft:!1,editUrl:"https://github.com/mateusz1913/rnbridgingtutorial/tree/main/docs/docs/guides/app-info-module/ios-impl.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"iOS implementation",sidebar_position:4,title:"iOS implementation"},sidebar:"tutorialSidebar",previous:{title:"JS specification",permalink:"/rnbridgingtutorial/docs/guides/app-info-module/js-spec"},next:{title:"Android implementation",permalink:"/rnbridgingtutorial/docs/guides/app-info-module/android-impl"}},E={},R=[],y={toc:R},D="wrapper";function j(e){let{components:n,...t}=e;return(0,i.kt)(D,(0,o.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Let's use XCode, to write iOS code. Open XCode, by running this command from the root directory of your app:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"xed ios\n")),(0,i.kt)("p",null,"When workspace is opened, locate ",(0,i.kt)("inlineCode",{parentName:"p"},"Pods")," project and expand it. Search for ",(0,i.kt)("inlineCode",{parentName:"p"},"Development Pods")," and find ",(0,i.kt)("inlineCode",{parentName:"p"},"AppInfoPackage")," inside. When it's expanded, it will show all files that we created under ",(0,i.kt)("inlineCode",{parentName:"p"},"app-info-package/ios")," directory."),(0,i.kt)(a.Z,{groupId:"ios_lang",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"swift",label:"ObjC++ & Swift",mdxType:"TabItem"},(0,i.kt)(v,{mdxType:"IosSwiftImpl"})),(0,i.kt)(l.Z,{value:"objc",label:"ObjC++ only",mdxType:"TabItem"},(0,i.kt)(b,{mdxType:"IosObjCImpl"}))),(0,i.kt)("p",null,"You can check training repo for ObjC & Swift implementation ",(0,i.kt)("a",{parentName:"p",href:"https://r.mtdv.me/FtXpuO4X9f"},"here")," and ObjC-only implementation ",(0,i.kt)("a",{parentName:"p",href:"https://r.mtdv.me/FtXpuO4X9f"},"here"),"."),(0,i.kt)("p",null,"That's iOS part, now let's go to Android!"))}j.isMDXComponent=!0}}]);